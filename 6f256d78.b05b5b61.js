(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{63:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return s})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return o}));var n=a(2),r=a(6),i=(a(0),a(73)),s={id:"mostAPI",title:"Operator descriptions",sidebar_label:"Operator descriptions"},b={unversionedId:"mostAPI",id:"mostAPI",isDocsHomePage:!1,title:"Operator descriptions",description:"most.js API taken from here",source:"@site/docs/most-api.md",permalink:"/docs/mostAPI",editUrl:"https://github.com/nodefluent/kafka-streams/website/docs/most-api.md",sidebar_label:"Operator descriptions",sidebar:"someSidebar",previous:{title:"API info",permalink:"/docs/ksAPI"},next:{title:"Native Consumer/Producer Explanation",permalink:"/docs/native"}},c=[{value:"Notation",id:"notation",children:[{value:"Examples",id:"examples",children:[]},{value:"Consuming most.js streams with other libraries",id:"consuming-mostjs-streams-with-other-libraries",children:[]},{value:"Consuming draft ES Observables with most.js",id:"consuming-draft-es-observables-with-mostjs",children:[]}]},{value:"Creating streams",id:"creating-streams",children:[{value:"most.just",id:"mostjust",children:[]},{value:"most.fromPromise",id:"mostfrompromise",children:[]},{value:"most.from",id:"mostfrom",children:[]},{value:"most.periodic",id:"mostperiodic",children:[]},{value:"most.empty",id:"mostempty",children:[]},{value:"most.never",id:"mostnever",children:[]},{value:"most.iterate",id:"mostiterate",children:[]},{value:"most.unfold",id:"mostunfold",children:[]},{value:"most.generate",id:"mostgenerate",children:[]},{value:"most.fromEvent",id:"mostfromevent",children:[]},{value:"startWith",id:"startwith",children:[]},{value:"concat",id:"concat",children:[]}]},{value:"Handling errors",id:"handling-errors",children:[{value:"recoverWith",id:"recoverwith",children:[]},{value:"most.throwError",id:"mostthrowerror",children:[]}]},{value:"Transforming streams",id:"transforming-streams",children:[{value:"map",id:"map",children:[]},{value:"constant",id:"constant",children:[]},{value:"scan",id:"scan",children:[]},{value:"chain",id:"chain",children:[]},{value:"continueWith",id:"continuewith",children:[]},{value:"concatMap",id:"concatmap",children:[]},{value:"ap",id:"ap",children:[]},{value:"timestamp",id:"timestamp",children:[]},{value:"tap",id:"tap",children:[]}]},{value:"Filtering streams",id:"filtering-streams",children:[{value:"filter",id:"filter",children:[]},{value:"skipRepeats",id:"skiprepeats",children:[]},{value:"skipRepeatsWith",id:"skiprepeatswith",children:[]}]},{value:"Transducer support",id:"transducer-support",children:[{value:"transduce",id:"transduce",children:[]}]},{value:"Slicing streams",id:"slicing-streams",children:[{value:"slice",id:"slice",children:[]},{value:"take",id:"take",children:[]},{value:"skip",id:"skip",children:[]},{value:"takeWhile",id:"takewhile",children:[]},{value:"skipWhile",id:"skipwhile",children:[]},{value:"until",id:"until",children:[]},{value:"since",id:"since",children:[]},{value:"during",id:"during",children:[]}]},{value:"Looping",id:"looping",children:[{value:"loop",id:"loop",children:[]}]},{value:"Adapting fluent APIs",id:"adapting-fluent-apis",children:[{value:"thru",id:"thru",children:[]}]},{value:"Consuming streams",id:"consuming-streams",children:[{value:"reduce",id:"reduce",children:[]},{value:"observe",id:"observe",children:[]},{value:"drain",id:"drain",children:[]},{value:"subscribe",id:"subscribe",children:[]},{value:"<code>observe</code>/<code>forEach</code> or <code>subscribe</code>",id:"observeforeach-or-subscribe",children:[]}]},{value:"Combining streams",id:"combining-streams",children:[{value:"merge",id:"merge",children:[]},{value:"mergeArray",id:"mergearray",children:[]},{value:"combine",id:"combine",children:[]},{value:"combineArray",id:"combinearray",children:[]},{value:"sample",id:"sample",children:[]},{value:"sampleWith",id:"samplewith",children:[]},{value:"zip",id:"zip",children:[]}]},{value:"Combining higher-order streams",id:"combining-higher-order-streams",children:[{value:"switchLatest",id:"switchlatest",children:[]},{value:"join",id:"join",children:[]},{value:"mergeConcurrently",id:"mergeconcurrently",children:[]}]},{value:"Awaiting promises",id:"awaiting-promises",children:[{value:"awaitPromises",id:"awaitpromises",children:[]}]},{value:"Rate limiting streams",id:"rate-limiting-streams",children:[{value:"debounce",id:"debounce",children:[]},{value:"throttle",id:"throttle",children:[]}]},{value:"Delaying streams",id:"delaying-streams",children:[{value:"delay",id:"delay",children:[]}]},{value:"Sharing streams",id:"sharing-streams",children:[{value:"multicast",id:"multicast",children:[]}]}],m={rightToc:c};function o(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},m,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"mostjs-api-taken-from-here"},"most.js API ",Object(i.b)("a",Object(n.a)({parentName:"h1"},{href:"https://github.com/cujojs/most/blob/master/docs/api.md"}),"taken from here")),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Reading these docs",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#notation"}),"Notation")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/cujojs/most/wiki/Concepts"}),"Concepts")))),Object(i.b)("li",{parentName:"ol"},"API Notes",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#draft-es-observable-interop"}),"Draft ES Observable interop")))),Object(i.b)("li",{parentName:"ol"},"Creating streams",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostjust"}),"most.just"),", alias ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostjust"}),"most.of")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostfrompromise"}),"most.fromPromise")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostfrom"}),"most.from")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostperiodic"}),"most.periodic")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostempty"}),"most.empty")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostnever"}),"most.never")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostiterate"}),"most.iterate")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostunfold"}),"most.unfold")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostgenerate"}),"most.generate")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostfromevent"}),"most.fromEvent")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#startwith"}),"startWith")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#concat"}),"concat")))),Object(i.b)("li",{parentName:"ol"},"Handling errors",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#recoverwith"}),"recoverWith"),", alias ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#recoverwith"}),"flatMapError")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostthrowerror"}),"throwError")))),Object(i.b)("li",{parentName:"ol"},"Transforming streams",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#map"}),"map")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#constant"}),"constant")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#scan"}),"scan")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#chain"}),"chain"),", alias ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#chain"}),"flatMap")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#continuewith"}),"continueWith"),", alias ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#continuewith"}),"flatMapEnd")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#concatmap"}),"concatMap")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#ap"}),"ap")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#timestamp"}),"timestamp")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#tap"}),"tap")))),Object(i.b)("li",{parentName:"ol"},"Filtering streams",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#filter"}),"filter")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#skiprepeats"}),"skipRepeats")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#skiprepeatswith"}),"skipRepeatsWith")))),Object(i.b)("li",{parentName:"ol"},"Transducer support",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#transduce"}),"transduce")))),Object(i.b)("li",{parentName:"ol"},"Slicing streams",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#slice"}),"slice")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#take"}),"take")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#skip"}),"skip")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#takewhile"}),"takeWhile")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#skipwhile"}),"skipWhile")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#until"}),"until"),", alias ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#until"}),"takeUntil")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#since"}),"since"),", alias ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#since"}),"skipUntil")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#during"}),"during")))),Object(i.b)("li",{parentName:"ol"},"Looping",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#loop"}),"loop")))),Object(i.b)("li",{parentName:"ol"},"Adapting fluent APIs",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#thru"}),"thru")))),Object(i.b)("li",{parentName:"ol"},"Consuming streams",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#reduce"}),"reduce")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#observe"}),"observe"),", alias ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#observe"}),"forEach")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#drain"}),"drain")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#subscribe"}),"subscribe")))),Object(i.b)("li",{parentName:"ol"},"Combining streams",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#merge"}),"merge")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mergearray"}),"mergeArray")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#combine"}),"combine")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#combinearray"}),"combineArray")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#sample"}),"sample")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#samplewith"}),"sampleWith")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#zip"}),"zip")))),Object(i.b)("li",{parentName:"ol"},"Combining higher order streams",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#switchlatest"}),"switchLatest"),", alias ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#switchlatest"}),"switch")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#join"}),"join")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mergeconcurrently"}),"mergeConcurrently")))),Object(i.b)("li",{parentName:"ol"},"Awaiting promises",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#awaitpromises"}),"awaitPromises"),", alias ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#awaitpromises"}),"await")))),Object(i.b)("li",{parentName:"ol"},"Rate limiting streams",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#debounce"}),"debounce")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#throttle"}),"throttle")))),Object(i.b)("li",{parentName:"ol"},"Delaying streams",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#delay"}),"delay")))),Object(i.b)("li",{parentName:"ol"},"Sharing stream",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#multicast"}),"multicast"))))),Object(i.b)("h2",{id:"notation"},"Notation"),Object(i.b)("p",null,"You'll see diagrams like the following:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream1: -a-b-c-d->\n\nstream2: -a--b---c|\n\nstream3: -abc-def-X\n")),Object(i.b)("p",null,"These are timeline diagrams that try to give a simple, representative notion of how a stream behaves over time.  Time proceeds from left to right, using letters and symbols to indicate certain things:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"-")," - an instant in time where no event occurs"),Object(i.b)("li",{parentName:"ul"},"letters (a,b,c,d,etc) - an event at an instant in time"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"|")," - end of stream"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"X")," - an error occurred at an instant in time"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},">")," - stream continues infinitely",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Typically, ",Object(i.b)("inlineCode",{parentName:"li"},">")," means you can assume that a stream will continue to repeat some common pattern infinitely")))),Object(i.b)("h3",{id:"examples"},"Examples"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"stream: a|")),Object(i.b)("p",null,"A stream that emits ",Object(i.b)("inlineCode",{parentName:"p"},"a")," and then ends immediately."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"stream: a-b---|")),Object(i.b)("p",null,"A stream that emits ",Object(i.b)("inlineCode",{parentName:"p"},"a"),", then ",Object(i.b)("inlineCode",{parentName:"p"},"b"),", and some time later ends."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"stream: a-b-X")),Object(i.b)("p",null,"A stream that emits ",Object(i.b)("inlineCode",{parentName:"p"},"a"),", then ",Object(i.b)("inlineCode",{parentName:"p"},"b"),", then fails."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"stream: abc-def->")),Object(i.b)("p",null,"A stream that emits ",Object(i.b)("inlineCode",{parentName:"p"},"a"),", then ",Object(i.b)("inlineCode",{parentName:"p"},"b"),", then ",Object(i.b)("inlineCode",{parentName:"p"},"c"),", then nothing, then ",Object(i.b)("inlineCode",{parentName:"p"},"d"),", then ",Object(i.b)("inlineCode",{parentName:"p"},"e"),", then ",Object(i.b)("inlineCode",{parentName:"p"},"f"),", and then continues infinitely."),Object(i.b)("a",{name:"es7-observable-interop"}),"## Draft ES Observable interop",Object(i.b)("p",null,"Most.js implements a subset of the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/zenparsing/es-observable"}),"draft ES Observable proposal"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"stream[Symbol.observable]() -> Observable")," returns a compatible observable with a ",Object(i.b)("inlineCode",{parentName:"li"},"subscribe")," method that other implementations can consume."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#mostfrom"}),Object(i.b)("inlineCode",{parentName:"a"},"most.from(observable) -> Stream"))," coerces a compliant ",Object(i.b)("inlineCode",{parentName:"li"},"observable")," (one that provides ",Object(i.b)("inlineCode",{parentName:"li"},"[Symbol.observable]()"),") to a most.js stream."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#observe"}),Object(i.b)("inlineCode",{parentName:"a"},"stream.forEach(f) -> Promise"))," is fully compatible with the draft ES Observable ",Object(i.b)("inlineCode",{parentName:"li"},"forEach")," API."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#subscribe"}),Object(i.b)("inlineCode",{parentName:"a"},"stream.subscribe(observer) -> Subscription"))," subscribes to a most.js Stream using the draft ES Observable ",Object(i.b)("inlineCode",{parentName:"li"},"subscribe")," API.")),Object(i.b)("p",null,"This allows most.js to interoperate seamlessly with other implementations, such as ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://reactivex.io/rxjs/"}),"RxJS 5"),", and ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://rpominov.github.io/kefir/"}),"Kefir"),"."),Object(i.b)("h3",{id:"consuming-mostjs-streams-with-other-libraries"},"Consuming most.js streams with other libraries"),Object(i.b)("p",null,"Consult the documentation of other libraries for specifics.  Any functions and methods that accept draft ES Observables should accept most.js Streams seamlessly."),Object(i.b)("h3",{id:"consuming-draft-es-observables-with-mostjs"},"Consuming draft ES Observables with most.js"),Object(i.b)("p",null,"Use ",Object(i.b)("inlineCode",{parentName:"p"},"most.from")," to coerce any observable to a most.js stream:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import { from } from 'most'\n\nconst mostStream = from(anyObservable)\n")),Object(i.b)("p",null,"You can use ",Object(i.b)("inlineCode",{parentName:"p"},"most.from")," in other creative ways as well:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const functionThatReturnsAnObservable = a => // return an observable\n\n// Using chain (aka flatMap)\nconst mostStream = //...\n\n// Use .map.chain\nmostStream.map(functionThatReturnsAnObservable).chain(from)\n    .observe(b => console.log(b))\n\n// Or use function composition, using your favorite FP lib\nmostStream.chain(compose(functionThatReturnsAnObservable, from))\n")),Object(i.b)("p",null,"A similar approach works with other higher order operations such as ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#join"}),Object(i.b)("inlineCode",{parentName:"a"},"join"))," and ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#switch"}),Object(i.b)("inlineCode",{parentName:"a"},"switch")),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"mostStream.map(functionThatReturnsAnObservable).map(from).join()...\n\nmostStream.map(functionThatReturnsAnObservable).map(from).switch()...\n")),Object(i.b)("p",null,"Or with merge, combine, etc. by coercing first"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"arrayOfObservables = [...]\nmost.mergeArray(arrayOfObservables.map(from))\nmost.combineArray(combineFunction, arrayOfObservables.map(from))\n")),Object(i.b)("h2",{id:"creating-streams"},"Creating streams"),Object(i.b)("h3",{id:"mostjust"},"most.just"),Object(i.b)("p",null,"Alias: ",Object(i.b)("inlineCode",{parentName:"p"},"most.of")),Object(i.b)("h4",{id:"mostjustx---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.just(x) -> Stream")),Object(i.b)("h4",{id:"mostofx---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.of(x) -> Stream")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"most.of(x): x|\n")),Object(i.b)("p",null,"Create a stream containing only x."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const stream = most.of('hello');\nstream.observe(x => console.log(x)); // logs hello\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// Use `just` for destructured ES6 import\nimport { just } from 'most';\nconst stream = just('hello');\nstream.observe(x => console.log(x));\n")),Object(i.b)("h3",{id:"mostfrompromise"},"most.fromPromise"),Object(i.b)("h4",{id:"mostfrompromisepromise---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.fromPromise(promise) -> Stream")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"promise:                   ----a\nmost.fromPromise(promise): ----a|\n")),Object(i.b)("p",null,"Create a stream containing the outcome of a promise.  If the promise fulfills, the stream will contain the promise's value.  If the promise rejects, the stream will be in an error state with the promise's rejection reason as its error.  See ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#recoverwith"}),"recoverWith")," for error recovery."),Object(i.b)("h3",{id:"mostfrom"},"most.from"),Object(i.b)("h4",{id:"mostfromiterable--observable---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.from(Iterable | Observable) -> Stream")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"observable:            -a--b--c--c--\x3e\nmost.from(observable): -a--b--c--c--\x3e\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"most.from([1,2,3,4]): 1234|\n")),Object(i.b)("p",null,"Create a stream containing all items from an Iterable or Observable."),Object(i.b)("p",null,"The observable must provide minimal draft ES observable compliance as per the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/zenparsing/es-observable"}),"es-observable draft"),": it must have a ",Object(i.b)("inlineCode",{parentName:"p"},"[Symbol.observable]()")," method that returns an object with a well-behaved ",Object(i.b)("inlineCode",{parentName:"p"},".subscribe()")," method."),Object(i.b)("p",null,"The iterable can be an Array, Array-like, or anything that supports the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable"}),"iterable protocol")," or ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol"}),"iterator protocol"),", such as a ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*"}),"generator"),". Providing a finite iterable, such as an Array, creates a finite stream. Providing an infinite iterable, such as an infinite generator, creates an infinite stream."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note:")," ",Object(i.b)("inlineCode",{parentName:"p"},"from")," will fail fast by throwing a ",Object(i.b)("inlineCode",{parentName:"p"},"TypeError")," ",Object(i.b)("em",{parentName:"p"},"synchronously")," when passed a value that is not an ",Object(i.b)("inlineCode",{parentName:"p"},"Iterable"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Iterator"),", or ",Object(i.b)("inlineCode",{parentName:"p"},"Observable"),".  This indicates an invalid use of ",Object(i.b)("inlineCode",{parentName:"p"},"from"),", which should be fixed/prevented rather than handled at runtime."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// Logs 1 2 3 4\nmost.from([1,2,3,4])\n    .forEach(console.log.bind(console));\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// Strings are Array-like, this works\n// Logs a b c d\nmost.from('abcd')\n    .forEach(console.log.bind(console));\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"function* numbers() {\n    for(i=0 ;; ++i) {\n        yield i;\n    }\n}\n\n// Create an infinite stream of numbers\nvar stream = most.from(numbers());\n\n// Limit the stream to the first 100 numbers\nstream.take(100)\n    .forEach(console.log.bind(console));\n")),Object(i.b)("h3",{id:"mostperiodic"},"most.periodic"),Object(i.b)("h4",{id:"mostperiodicperiod---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.periodic(period) -> Stream")),Object(i.b)("h4",{id:"mostperiodicperiod-x---stream-deprecated"},Object(i.b)("inlineCode",{parentName:"h4"},"most.periodic(period, x) -> Stream")," (deprecated)"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note:")," periodic's second argument (",Object(i.b)("inlineCode",{parentName:"p"},"x"),") is deprecated. To create a periodic stream with a specific value use ",Object(i.b)("inlineCode",{parentName:"p"},"constant(x, periodic(period))")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"most.periodic(2): x-x-x-x-x-x-> (x === undefined)\nmost.periodic(5, a): a----a----a->\n")),Object(i.b)("p",null,"Create an infinite stream containing events that arrive every ",Object(i.b)("inlineCode",{parentName:"p"},"period")," milliseconds, and whose value is ",Object(i.b)("inlineCode",{parentName:"p"},"undefined"),"."),Object(i.b)("h3",{id:"mostempty"},"most.empty"),Object(i.b)("h4",{id:"mostempty---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.empty() -> Stream")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"most.empty(): |\n")),Object(i.b)("p",null,"Create an already-ended stream containing no events."),Object(i.b)("h3",{id:"mostnever"},"most.never"),Object(i.b)("h4",{id:"mostnever---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.never() -> Stream")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"most.never(): ----\x3e\n")),Object(i.b)("p",null,"Create a stream that contains no events and never ends."),Object(i.b)("h3",{id:"mostiterate"},"most.iterate"),Object(i.b)("h4",{id:"mostiteratef-initial---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.iterate(f, initial) -> Stream")),Object(i.b)("p",null,"Build an infinite stream by computing successive items iteratively.  Conceptually, the stream will contain: ",Object(i.b)("inlineCode",{parentName:"p"},"[initial, f(initial), f(f(initial)), ...]")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// An infinite stream of all integers >= 0, ie\n// 0, 1, 2, 3, 4, 5, ...\nmost.iterate(function(x) {\n    return x + 1;\n}, 0);\n")),Object(i.b)("p",null,"The iterating function may return a promise.  This allows ",Object(i.b)("inlineCode",{parentName:"p"},"most.iterate")," to be used to build asynchronous streams of future values.  For example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// An infinite stream of all integers >= 0, each delayed\n// by 1 more millisecond than the previous.\n// IOW, a stream that decelerates as it produces values:\n// 0 (immediately)\n// 1 (1 millisecond after 0)\n// 2 (2 millisecond after 1)\n// 3 (3 millisecond after 2)\n// ... etc\n// Take only the first 10\nmost.iterate(x => delay(x + 1)).take(10);\n\n// Simple promise delay helper\nconst delay = y =>\n    new Promise(resolve => setTimeout(resolve, y, y), 0);\n")),Object(i.b)("h3",{id:"mostunfold"},"most.unfold"),Object(i.b)("h4",{id:"mostunfoldf-seed---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.unfold(f, seed) -> Stream")),Object(i.b)("p",null,"Build a stream by computing successive items.  Whereas ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#reduce"}),Object(i.b)("inlineCode",{parentName:"a"},"reduce"))," tears down a stream to a final value, ",Object(i.b)("inlineCode",{parentName:"p"},"unfold")," builds up a stream from a seed value."),Object(i.b)("p",null,"The unfolding function accepts a seed value and must return a tuple: ",Object(i.b)("inlineCode",{parentName:"p"},"{value:*, seed:*, done:boolean}"),", or a promise for a tuple.  Returning a promise allows ",Object(i.b)("inlineCode",{parentName:"p"},"most.unfold")," to be used to build asynchronous streams of future values."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tuple.value")," will be emitted as an event."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tuple.seed")," will be passed to the next invocation of the unfolding function."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tuple.done")," can be used to stop unfolding.  When ",Object(i.b)("inlineCode",{parentName:"li"},"tuple.done == true"),", unfolding will stop.  Additionally, when ",Object(i.b)("inlineCode",{parentName:"li"},"tuple.done == true"),":",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tuple.value")," ",Object(i.b)("strong",{parentName:"li"},"(deprecated)")," will be used as the stream's end signal value.  In future versions, ",Object(i.b)("inlineCode",{parentName:"li"},"tuple.value")," will be ",Object(i.b)("em",{parentName:"li"},"ignored")," when ",Object(i.b)("inlineCode",{parentName:"li"},"tuple.done")," is ",Object(i.b)("inlineCode",{parentName:"li"},"true")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tuple.seed")," will be ignored")))),Object(i.b)("p",null,"Note that if the unfolding function never returns a tuple with ",Object(i.b)("inlineCode",{parentName:"p"},"tuple.done == true"),", the stream will be infinite."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"const urlPrefix = 'product/'\n\nconst fetch = url => {\n    // ... fetch content and return a promise\n    return Promise.resolve('...')\n}\n\n// Unfold an infinite stream of products, producing a stream of:\n// [rest('product/1'), rest('product/2'), rest('product/3'), ...]\nmost.unfold(id =>\n    fetch(urlPrefix + id).then(content => {\n        return { value: content, seed: id + 1 }\n    }), 1)\n")),Object(i.b)("h3",{id:"mostgenerate"},"most.generate"),Object(i.b)("h4",{id:"mostgenerategenerator-args---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.generate(generator, ...args) -> Stream")),Object(i.b)("p",null,"Build a stream by running an ",Object(i.b)("em",{parentName:"p"},"asynchronous generator"),": a generator which yields promises."),Object(i.b)("p",null,"When the generator yields a promise, the promise's fulfillment value will be added to the stream.  If the promise rejects, an exception will be thrown in the generator.  You can use ",Object(i.b)("inlineCode",{parentName:"p"},"try/catch")," to handle the exception."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"function delayPromise(ms, value) {\n    return new Promise(resolve => setTimeout(() => resolve(value), ms));\n}\n\nfunction* countdown(delay, start) {\n    for(let i = start; i > 0; --i) {\n        yield delayPromise(delay, i);\n    }\n}\n\n// Logs\n// 3 (after 1 second)\n// 2 (after 1 more second)\n// 1 (after 1 more second)\nmost.generate(countdown, 1000, 3)\n    .observe(x => console.log(x))\n")),Object(i.b)("h3",{id:"mostfromevent"},"most.fromEvent"),Object(i.b)("h4",{id:"mostfromeventeventtype-source--usecapturefalse---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.fromEvent(eventType, source [, useCapture=false]) -> Stream")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"source:                            -a--b-c---d->\nmost.fromEvent(eventType, source): -a--b-c---d->\n")),Object(i.b)("p",null,"Create a stream containing events from the provided ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget"}),"EventTarget"),", such as a DOM element, or ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://nodejs.org/api/events.html#events_class_events_eventemitter"}),"EventEmitter"),".  This provides a simple way to coerce existing event sources into streams."),Object(i.b)("p",null,"When passing an EventTarget, you can provide ",Object(i.b)("inlineCode",{parentName:"p"},"useCapture")," as the 3rd parameter, and it will be passed through to ",Object(i.b)("inlineCode",{parentName:"p"},"addEventListener")," and ",Object(i.b)("inlineCode",{parentName:"p"},"removeEventListener"),".  When not provided, ",Object(i.b)("inlineCode",{parentName:"p"},"useCapture")," defaults to ",Object(i.b)("inlineCode",{parentName:"p"},"false"),"."),Object(i.b)("p",null,"When the stream ends (for example, by using ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#take"}),"take"),", ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#until"}),"takeUntil"),", etc.), it will automatically be disconnected from the event source.  For example, in the case of DOM events, the underlying DOM event listener will be removed automatically."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Notes on EventEmitter")),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"When source event has more than one argument, all the arguments will be aggregated into array in resulting Stream."),Object(i.b)("li",{parentName:"ol"},"EventEmitters and EventTargets, such as DOM nodes, behave differently in that EventEmitter allows events to be delivered in the same tick as a listener is added.  When using EventEmitter, ",Object(i.b)("inlineCode",{parentName:"li"},"most.fromEvent"),", will ",Object(i.b)("em",{parentName:"li"},"ensure asynchronous event delivery"),', thereby preventing hazards of "maybe sync, maybe async" (aka zalgo) event delivery.')),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"const clicks = most.fromEvent('click', document.querySelector('.the-button'));\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// We can do some event delegation by applying a filter to the stream\n// in conjunction with e.target.matches this will allow only events with\n// .the-button class to be processed\nvar container = document.querySelector('.container');\nmost.fromEvent('click', container)\n    .filter(e => e.target.matches('.the-button'))\n    .forEach(event => { /* do something with event */ })\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Using preventDefault\nconst form = document.querySelector('form');\nmost.fromEvent('submit', form)\n    .tap(e => e.preventDefault())\n    .map(parseForm)\n    .map(JSON.stringify)\n    .forEach(event => { /* do something with JSON data */ })\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Using event delegation with Element.matches\n// This allows only events with the .toggle-button class\n// It also only calls preventDefault on allowed events\nconst container = document.querySelector('.container');\nmost.fromEvent('click', container)\n    .filter(e => e.target.matches('.toggle-button'))\n    .tap(e => e.preventDefault())\n    .forEach(event => { /* do something with event */ })\n")),Object(i.b)("h3",{id:"startwith"},"startWith"),Object(i.b)("h4",{id:"streamstartwithx---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.startWith(x) -> Stream")),Object(i.b)("h4",{id:"moststartwithx-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.startWith(x, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream containing ",Object(i.b)("inlineCode",{parentName:"p"},"x")," followed by all events in ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:              a-b-c-d->\nstream.startWith(x): xa-b-c-d->\n")),Object(i.b)("h3",{id:"concat"},"concat"),Object(i.b)("h4",{id:"stream1concatstream2---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream1.concat(stream2) -> Stream")),Object(i.b)("h4",{id:"mostconcatstream1-stream2---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.concat(stream1, stream2) -> Stream")),Object(i.b)("p",null,"Create a new stream containing all events in ",Object(i.b)("inlineCode",{parentName:"p"},"stream1")," followed by all events in ",Object(i.b)("inlineCode",{parentName:"p"},"stream2"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream1:                 -a-b-c|\nstream2:                 -d-e-f->\nstream1.concat(stream2): -a-b-c-d-e-f->\n")),Object(i.b)("p",null,"Note that this effectively ",Object(i.b)("em",{parentName:"p"},"timeshifts")," events from ",Object(i.b)("inlineCode",{parentName:"p"},"stream2")," past the end time of ",Object(i.b)("inlineCode",{parentName:"p"},"stream1"),".  In contrast, other operations such as ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#combine"}),Object(i.b)("inlineCode",{parentName:"a"},"combine")),", ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#merge"}),Object(i.b)("inlineCode",{parentName:"a"},"merge")),", ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#chain"}),"chain")," ",Object(i.b)("em",{parentName:"p"},"preserve event arrival times"),", allowing events from the multiple combined streams to interleave."),Object(i.b)("h2",{id:"handling-errors"},"Handling errors"),Object(i.b)("h3",{id:"recoverwith"},"recoverWith"),Object(i.b)("p",null,"Alias: ",Object(i.b)("strong",{parentName:"p"},"flatMapError")),Object(i.b)("h4",{id:"streamrecoverwithf---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.recoverWith(f) -> Stream")),Object(i.b)("h4",{id:"mostrecoverwithf-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.recoverWith(f, stream) -> Stream")),Object(i.b)("p",null,"Recover from a stream failure by calling a function to create a new stream."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:                 -a-b-c-X\nf(X):                   -d-e-f->\nstream.recoverWith(f): -a-b-c-d-e-f->\n")),Object(i.b)("p",null,"When a stream fails with an error, the error will be passed to ",Object(i.b)("inlineCode",{parentName:"p"},"f"),".  ",Object(i.b)("inlineCode",{parentName:"p"},"f")," must return a new stream to replace the error."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"const fetch = url => {\n    // ... fetch content and return a promise\n    return Promise.resolve('...')\n}\n\nconst stream = most.fromPromise(fetch('http://myapi.com/things'));\n\n// Try to process data from the real API, but fall back\n// to some default data if that fails.\nstream.map(JSON.parse)\n    .recoverWith(e => most.of(defaultData))\n    .forEach(processData);\n")),Object(i.b)("h3",{id:"mostthrowerror"},"most.throwError"),Object(i.b)("h4",{id:"mostthrowerrorerror---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.throwError(error) -> Stream")),Object(i.b)("p",null,"Create a stream in the error state.  This can be useful for functions that need to return a stream, but need to signal an error."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"most.throwError(X): X\n")),Object(i.b)("h2",{id:"transforming-streams"},"Transforming streams"),Object(i.b)("h3",{id:"map"},"map"),Object(i.b)("h4",{id:"streammapf---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.map(f) -> Stream")),Object(i.b)("h4",{id:"mostmapf-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.map(f, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream by applying ",Object(i.b)("inlineCode",{parentName:"p"},"f")," to each event of the input stream."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:           -a-b-c-d->\nstream.map(add1): -f(a)-f(b)-f(c)-f(d)->\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// Logs 2 3 4 5\nmost.from([1,2,3,4])\n    .map(function(x) {\n        return x + 1;\n    })\n    .forEach(console.log.bind(console));\n")),Object(i.b)("h3",{id:"constant"},"constant"),Object(i.b)("h4",{id:"streamconstantx---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.constant(x) -> Stream")),Object(i.b)("h4",{id:"mostconstantx-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.constant(x, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream by replacing each event of the input stream with ",Object(i.b)("inlineCode",{parentName:"p"},"x"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:             -a-b-c-d->\nstream.constant(x): -x-x-x-x->\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// Logs 1 1 1 1\nmost.from([1,2,3,4])\n    .constant(1)\n    .forEach(console.log.bind(console));\n")),Object(i.b)("h3",{id:"scan"},"scan"),Object(i.b)("h4",{id:"streamscanf-initial---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.scan(f, initial) -> Stream")),Object(i.b)("h4",{id:"mostscanf-initial-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.scan(f, initial, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream containing incrementally accumulated results, starting with the provided initial value."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"function f(accumulated, x) -> newAccumulated")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:              -1-2-3->\nstream.scan(add, 0): 01-3-6->\n")),Object(i.b)("p",null,"Unlike ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#reduce"}),"reduce")," which produces a single, final result, scan emits incremental results.  The resulting stream is of the same proportion as the original.  For example, if the original contains 10 events, the resulting stream will contain 11 (the initial value, followed by 10 incremental events).  If the original stream is infinite, the resulting stream will be infinite."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Logs a ab abc abcd\nmost.from(['a', 'b', 'c', 'd'])\n    .scan((string, letter) => string + letter, '')\n    .forEach(s => console.log(s));\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Maintain a sliding window of (up to) 3 values in an array\n\n// A stream containing all integers >= 0\nconst numbers = most.iterate(x => x + 1, 0);\n\nconst nextWindow = (slidingWindow, x) =>\n    slidingWindow.concat(x).slice(-3)\n\n// Logs\n// []\n// [0]\n// [0,1]\n// [0,1,2]\n// [1,2,3]\n// [2,3,4]\n// ... etc ...\nnumbers.scan(nextWindow, [])\n    .take(10)\n    .forEach(array => console.log(array));\n")),Object(i.b)("h3",{id:"chain"},"chain"),Object(i.b)("p",null,"Alias: ",Object(i.b)("strong",{parentName:"p"},"flatMap")),Object(i.b)("h4",{id:"streamchainf---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.chain(f) -> Stream")),Object(i.b)("h4",{id:"mostchainf-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.chain(f, stream) -> Stream")),Object(i.b)("p",null,"Transform each event in ",Object(i.b)("inlineCode",{parentName:"p"},"stream")," into a stream, and then merge it into the resulting stream. Note that ",Object(i.b)("inlineCode",{parentName:"p"},"f")," ",Object(i.b)("em",{parentName:"p"},"must")," return a stream."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"function f(x) -> Stream")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:            -a----b----c|\nf(a):               1--2--3|\nf(b):                    1----2----3|\nf(c):                           1-2-3|\nstream.chain(f):   -1--2-13---2-1-233|\n")),Object(i.b)("p",null,"Note the difference between ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#concatmap"}),Object(i.b)("inlineCode",{parentName:"a"},"concatMap"))," and ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#chain"}),Object(i.b)("inlineCode",{parentName:"a"},"chain")),": ",Object(i.b)("inlineCode",{parentName:"p"},"concatMap")," concatenates, while ",Object(i.b)("inlineCode",{parentName:"p"},"chain")," merges."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Logs: 1 2 1 1 2 1 1 2 2 2\nmost.from([1, 2])\n    .chain(x => most.periodic(x * 10).take(5).constant(x))\n    .observe(x => console.log(x));\n")),Object(i.b)("h3",{id:"continuewith"},"continueWith"),Object(i.b)("h4",{id:"streamcontinuewithf---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.continueWith(f) -> Stream")),Object(i.b)("h4",{id:"mostcontinuewithf-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.continueWith(f, stream) -> Stream")),Object(i.b)("p",null,"Replace the end signal with a new stream returned by f. Note that f ",Object(i.b)("em",{parentName:"p"},"must")," return a stream."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"function f(x) -> Stream")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:               -a-b-c-d-e-f->\nstream.take(4):       -a-b-c-d|end\nf(end):                        1-2-3-4-5->\nstream.continueWith(f): -a-b-c-d-1-2-3-4-5->\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"most.periodic(10, 'x')\n    .take(4)\n    .continueWith(() => most.iterate(x => x + 1, 1).take(5))\n        .observe(x => console.log(x));\n  // Logs: x 4 times... ends and then logs 1, 2, 3, 4, 5\n")),Object(i.b)("h3",{id:"concatmap"},"concatMap"),Object(i.b)("h4",{id:"streamconcatmapf---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.concatMap(f) -> Stream")),Object(i.b)("h4",{id:"mostconcatmapf-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.concatMap(f, stream) -> Stream")),Object(i.b)("p",null,"Transform each event in ",Object(i.b)("inlineCode",{parentName:"p"},"stream")," into a stream, and then concatenate it onto the end of the resulting stream. Note that ",Object(i.b)("inlineCode",{parentName:"p"},"f")," ",Object(i.b)("em",{parentName:"p"},"must")," return a stream."),Object(i.b)("p",null,"The mapping function ",Object(i.b)("inlineCode",{parentName:"p"},"f")," is applied ",Object(i.b)("em",{parentName:"p"},"lazily"),".  That is, ",Object(i.b)("inlineCode",{parentName:"p"},"f")," is called only once it is time to concatenate a new stream."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"function f(x) -> Stream")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:              -a----b----c|\nf(a):                 1--2--3|\nf(b):                      1----2----3|\nf(c):                             1-2-3|\nstream.concatMap(f): -1--2--31----2----31-2-3|\nf called lazily:      ^      ^          ^\n")),Object(i.b)("p",null,"Note the difference between ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#concatmap"}),Object(i.b)("inlineCode",{parentName:"a"},"concatMap"))," and ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#chain"}),Object(i.b)("inlineCode",{parentName:"a"},"chain")),": ",Object(i.b)("inlineCode",{parentName:"p"},"concatMap")," concatenates, while ",Object(i.b)("inlineCode",{parentName:"p"},"chain")," merges."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Logs: 1 1 1 1 1 2 2 2 2 2\nmost.from([1, 2])\n    .concatMap(x => most.periodic(x * 10).take(5).constant(x))\n    .observe(console.log.bind(console));\n")),Object(i.b)("h3",{id:"ap"},"ap"),Object(i.b)("h4",{id:"streamoffunctionsapstream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"streamOfFunctions.ap(stream) -> Stream")),Object(i.b)("h4",{id:"mostapstreamoffunctions-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.ap(streamOfFunctions, stream) -> Stream")),Object(i.b)("p",null,"Apply the latest function in ",Object(i.b)("inlineCode",{parentName:"p"},"streamOfFunctions")," to the latest value in ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"streamOfFunctions:            --f---------g--------h------\x3e\nstream:                       -a-------b-------c-------d--\x3e\nstreamOfFunctions.ap(stream): --fa-----fb-gb---gc--hc--hd->\n")),Object(i.b)("p",null,"In effect, ",Object(i.b)("inlineCode",{parentName:"p"},"ap")," applies a ",Object(i.b)("em",{parentName:"p"},"time-varying function")," to a ",Object(i.b)("em",{parentName:"p"},"time-varying value"),"."),Object(i.b)("h3",{id:"timestamp"},"timestamp"),Object(i.b)("h4",{id:"streamtimestamp---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.timestamp() -> Stream")),Object(i.b)("h4",{id:"mosttimestampstream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.timestamp(stream) -> Stream")),Object(i.b)("p",null,"Materialize event timestamps, transforming ",Object(i.b)("inlineCode",{parentName:"p"},"Stream<X>")," into ",Object(i.b)("inlineCode",{parentName:"p"},"Stream<{ time:number, value:X }>")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Logs\n// { time: 1418740004055, value: 'hello' }\n// { time: 1418740004065, value: 'hello' }\n// { time: 1418740004075, value: 'hello' }\n// { time: 1418740004085, value: 'hello' }\n// ... etc\nmost.periodic(10).constant('hello')\n    .timestamp()\n    .take(10)\n    .observe(console.log.bind(console));\n")),Object(i.b)("h3",{id:"tap"},"tap"),Object(i.b)("h4",{id:"streamtapf---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.tap(f) -> Stream")),Object(i.b)("h4",{id:"mosttapf-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.tap(f, stream) -> Stream")),Object(i.b)("p",null,"Perform a side-effect for each event in ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:        -a-b-c-d->\nstream.tap(f): -a-b-c-d->\n")),Object(i.b)("p",null,"For each event in ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),", ",Object(i.b)("inlineCode",{parentName:"p"},"f")," is called, but the value of its result is ignored. If ",Object(i.b)("inlineCode",{parentName:"p"},"f")," fails (ie throws), then the returned stream will also fail.  The stream returned by ",Object(i.b)("inlineCode",{parentName:"p"},"tap")," will contain the same events as the original stream."),Object(i.b)("h2",{id:"filtering-streams"},"Filtering streams"),Object(i.b)("h3",{id:"filter"},"filter"),Object(i.b)("h4",{id:"streamfilterpredicate---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.filter(predicate) -> Stream")),Object(i.b)("h4",{id:"mostfilterpredicate-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.filter(predicate, stream) -> Stream")),Object(i.b)("p",null,"Create a stream containing only events for which ",Object(i.b)("inlineCode",{parentName:"p"},"predicate")," returns truthy."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:              -1-2-3-4->\nstream.filter(even): ---2---4->\n")),Object(i.b)("h3",{id:"skiprepeats"},"skipRepeats"),Object(i.b)("h4",{id:"streamskiprepeats---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.skipRepeats() -> Stream")),Object(i.b)("h4",{id:"mostskiprepeatsstream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.skipRepeats(stream) -> Stream")),Object(i.b)("p",null,"Create a new stream with ",Object(i.b)("em",{parentName:"p"},"adjacent")," repeated events removed."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:            -1-2-2-3-4-4-5->\nstream.skipRepeats(): -1-2---3-4---5->\n")),Object(i.b)("p",null,"Note that ",Object(i.b)("inlineCode",{parentName:"p"},"===")," is used to identify duplicate items.  To use a different comparison, use ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#skiprepeatswith"}),Object(i.b)("inlineCode",{parentName:"a"},"skipRepeatsWith"))),Object(i.b)("h3",{id:"skiprepeatswith"},"skipRepeatsWith"),Object(i.b)("h4",{id:"streamskiprepeatswithequals---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.skipRepeatsWith(equals) -> Stream")),Object(i.b)("h4",{id:"mostskiprepeatswithequals-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.skipRepeatsWith(equals, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream with ",Object(i.b)("em",{parentName:"p"},"adjacent")," repeated events removed, using the provided ",Object(i.b)("inlineCode",{parentName:"p"},"equals")," function."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:                              -a-b-B-c-D-d-e->\nstream.skipRepeatsWith(equalsIgnoreCase): -a-b---c-D---e->\n")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"equals")," function should accept two values and return truthy if the two values are equal, or falsy if they are not equal."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"function equals(a, b) -> boolean")),Object(i.b)("h2",{id:"transducer-support"},"Transducer support"),Object(i.b)("h3",{id:"transduce"},"transduce"),Object(i.b)("h4",{id:"streamtransducetransducer---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.transduce(transducer) -> Stream")),Object(i.b)("h4",{id:"mosttransducetransducer-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.transduce(transducer, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream by passing items through the provided transducer."),Object(i.b)("p",null,Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://simplectic.com/blog/2014/transducers-explained-1/"}),"Transducers")," are composable transformations.  They may map, filter, add items to, drop items from, or otherwise transform an event stream.  The primary benefit of transducers is that they are composable and reusable across any data structures that support them (see note on performance below)"),Object(i.b)("p",null,"Most.js supports any transducer that implements the ",Object(i.b)("em",{parentName:"p"},"de facto")," JavaScript transducer protocol.  For example, two popular transducers libraries are ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/cognitect-labs/transducers-js"}),"transducers-js")," and ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/jlongster/transducers.js"}),"transducers.js"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Create a transducer that slices, filters, and maps\nimport transducers from 'transducers-js'\nvar transducer = transducers.comp(\n    transducers.take(4),\n    transducers.filter(x => x % 2 === 0),\n    transducers.map(x => x + 1)\n)\n\n// Logs 3 5\nmost.from([1,2,3,4,5,6,7,8,9])\n    .transduce(transducer)\n    .observe(x => console.log(x))\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note on transducer performance:")," Transducers perform single-pass transformation.  For many data structures, this can provide a significant performance improvement.  However, most.js's builtin combinators currently outperform popular transducer libraries.  The primary benefit of using transducers with most.js is reusability and portability."),Object(i.b)("h2",{id:"slicing-streams"},"Slicing streams"),Object(i.b)("h3",{id:"slice"},"slice"),Object(i.b)("h4",{id:"streamslicestart-end---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.slice(start, end) -> Stream")),Object(i.b)("h4",{id:"mostslicestart-end-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.slice(start, end, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream containing only events where ",Object(i.b)("inlineCode",{parentName:"p"},"start <= index < end"),", where ",Object(i.b)("inlineCode",{parentName:"p"},"index")," is the ordinal index of an event in ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:             -a-b-c-d-e-f->\nstream.slice(1, 4): ---b-c-d|\n\nstream:             -a-b-c|\nstream.slice(1, 4): ---b-c|\n")),Object(i.b)("p",null,"If stream contains fewer than ",Object(i.b)("inlineCode",{parentName:"p"},"start")," events, the returned stream will be empty."),Object(i.b)("h3",{id:"take"},"take"),Object(i.b)("h4",{id:"streamtaken---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.take(n) -> Stream")),Object(i.b)("h4",{id:"mosttaken-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.take(n, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream containing at most ",Object(i.b)("inlineCode",{parentName:"p"},"n")," events from ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:         -a-b-c-d-e-f->\nstream.take(3): -a-b-c|\n\nstream:         -a-b|\nstream.take(3): -a-b|\n")),Object(i.b)("p",null,"If ",Object(i.b)("inlineCode",{parentName:"p"},"stream")," contains fewer than ",Object(i.b)("inlineCode",{parentName:"p"},"n")," events, the returned stream will be effectively equivalent to ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),"."),Object(i.b)("h3",{id:"skip"},"skip"),Object(i.b)("h4",{id:"streamskipn---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.skip(n) -> Stream")),Object(i.b)("h4",{id:"mostskipn-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.skip(n, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream that omits the first ",Object(i.b)("inlineCode",{parentName:"p"},"n")," events from ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:         -a-b-c-d-e-f->\nstream.skip(3): -------d-e-f->\n\nstream:         -a-b-c-d-e|\nstream.skip(3): -------d-e|\n\nstream:         -a-b-c|\nstream.skip(3): ------|\n")),Object(i.b)("p",null,"If ",Object(i.b)("inlineCode",{parentName:"p"},"stream")," contains fewer than ",Object(i.b)("inlineCode",{parentName:"p"},"n")," events, the returned stream will be empty."),Object(i.b)("h3",{id:"takewhile"},"takeWhile"),Object(i.b)("h4",{id:"streamtakewhilepredicate---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.takeWhile(predicate) -> Stream")),Object(i.b)("h4",{id:"mosttakewhilepredicate-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.takeWhile(predicate, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream containing all events until ",Object(i.b)("inlineCode",{parentName:"p"},"predicate")," returns false."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:                 -2-4-5-6-8->\nstream.takeWhile(even): -2-4-|\n")),Object(i.b)("h3",{id:"skipwhile"},"skipWhile"),Object(i.b)("h4",{id:"streamskipwhilepredicate---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.skipWhile(predicate) -> Stream")),Object(i.b)("h4",{id:"mostskipwhilepredicate-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.skipWhile(predicate, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream containing all events after ",Object(i.b)("inlineCode",{parentName:"p"},"predicate")," returns false."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:                 -2-4-5-6-8->\nstream.skipWhile(even): -----5-6-8->\n")),Object(i.b)("h3",{id:"until"},"until"),Object(i.b)("p",null,"Alias: ",Object(i.b)("strong",{parentName:"p"},"takeUntil")),Object(i.b)("h4",{id:"streamuntilendsignal---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.until(endSignal) -> Stream")),Object(i.b)("h4",{id:"mostuntilendsignal-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.until(endSignal, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream containing all events until ",Object(i.b)("inlineCode",{parentName:"p"},"endSignal")," emits an event."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:                  -a-b-c-d-e-f->\nendSignal:               ------z->\nstream.until(endSignal): -a-b-c|\n")),Object(i.b)("p",null,"If ",Object(i.b)("inlineCode",{parentName:"p"},"endSignal")," is empty or never emits an event, then the returned stream will be effectively equivalent to ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Log mouse events until the user clicks. Note that DOM event handlers will\n// automatically be unregistered.\nmost.fromEvent('mousemove', document)\n    .until(most.fromEvent('click', document))\n    .forEach(mouseEvent => console.log(mouseEvent));\n")),Object(i.b)("h3",{id:"since"},"since"),Object(i.b)("p",null,"Alias: ",Object(i.b)("strong",{parentName:"p"},"skipUntil")),Object(i.b)("h4",{id:"streamsincestartsignal---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.since(startSignal) -> Stream")),Object(i.b)("h4",{id:"mostsincestartsignal-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.since(startSignal, stream) -> Stream")),Object(i.b)("p",null,"Create a new stream containing all events after ",Object(i.b)("inlineCode",{parentName:"p"},"startSignal")," emits its first event."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:                    -a-b-c-d-e-f->\nstartSignal:               ------z->\nstream.since(startSignal): -------d-e-f->\n")),Object(i.b)("p",null,"If ",Object(i.b)("inlineCode",{parentName:"p"},"startSignal")," is empty or never emits an event, then the returned stream will be effectively equivalent to ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#mostnever"}),Object(i.b)("inlineCode",{parentName:"a"},"never()")),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Start logging mouse events when the user clicks.\nmost.fromEvent('mousemove', document)\n    .since(most.fromEvent('click', document))\n    .forEach(mouseEvent => console.log(mouseEvent));\n")),Object(i.b)("h3",{id:"during"},"during"),Object(i.b)("h4",{id:"streamduringtimewindow"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.during(timeWindow)")),Object(i.b)("h4",{id:"mostduringtimewindow-stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.during(timeWindow, stream)")),Object(i.b)("p",null,"Create a new stream containing only events that occur during a dynamic ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/cujojs/most/wiki/Concepts#time-windows"}),"time window"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:                    -a-b-c-d-e-f-g->\ntimeWindow:                -----s\ns:                               -----t\nstream.during(timeWindow): -----c-d-e-|\n")),Object(i.b)("p",null,"This is similar to ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#slice"}),"slice"),", but uses time signals rather than indices to limit the stream."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// After the first click, log mouse move events for 1 second.\n// Note that DOM event handlers will automatically be unregistered.\nconst start = most.fromEvent('click', document);\nconst end = most.of().delay(1000);\n\n// Map the first click to a stream containing a 1 second delay\n// The click represents the window start time, after which\n// the window will be open for 1 second.\nconst timeWindow = start.constant(end);\n\nmost.fromEvent('mousemove', document)\n    .during(timeWindow)\n    .forEach(mouseEvent => console.log(mouseEvent));\n")),Object(i.b)("h2",{id:"looping"},"Looping"),Object(i.b)("h3",{id:"loop"},"loop"),Object(i.b)("h4",{id:"streamloopstepper-seed---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.loop(stepper, seed) -> Stream")),Object(i.b)("h4",{id:"mostloopstepper-seed-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.loop(stepper, seed, stream) -> Stream")),Object(i.b)("p",null,"Create a feedback loop that emits one value and feeds back another to be used in the next iteration."),Object(i.b)("p",null,'It allows you to maintain and update a "state" (aka feedback, aka ',Object(i.b)("inlineCode",{parentName:"p"},"seed")," for the next iteration) while emitting a different value.  In contrast, ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#scan"}),Object(i.b)("inlineCode",{parentName:"a"},"scan"))," feeds back and emits the same value."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Average an array of values\nconst average = values =>\n    values.reduce((sum, x) => sum + x, 0) / values.length\n\nconst stream = most.iterate(x => x + 1, 0)\n\n// Emit the simple (ie windowed) moving average of the 10 most recent values\nstream.loop((values, x) => {\n    values.push(x);\n    values = values.slice(-10); // Keep up to 10 most recent\n    const avg = average(values);\n\n    // Return { seed, value } pair.\n    // seed will feed back into next iteration\n    // value will be propagated\n    return { seed: values, value: avg };\n}, [])\n    .take(10)\n    .observe(avg => console.log(avg));\n")),Object(i.b)("h2",{id:"adapting-fluent-apis"},"Adapting fluent APIs"),Object(i.b)("h3",{id:"thru"},"thru"),Object(i.b)("h4",{id:"streamthrutransform---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.thru(transform) -> Stream")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"transform(stream: Stream) -> Stream")),Object(i.b)("p",null,"Use a functional API in fluent style."),Object(i.b)("p",null,"Functional APIs allow for the highest degree of modularity via external packages, such as ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/mostjs/hold"}),Object(i.b)("inlineCode",{parentName:"a"},"@most/hold")),", ",Object(i.b)("em",{parentName:"p"},"without the risks of modifying prototypes"),"."),Object(i.b)("p",null,"If you prefer using fluent APIs, ",Object(i.b)("inlineCode",{parentName:"p"},"thru")," allows using those functional APIs in a fluent style.  For example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"import hold from '@most/hold'\nimport { periodic } from 'most'\n\nperiodic(10, 1)\n    .take(5)\n    .scan((total, increment) => total + increment, 0)\n    .thru(hold)\n    .observe(x => console.log(x))\n")),Object(i.b)("p",null,"rather than mixing functional and fluent:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"import hold from '@most/hold'\nimport { periodic } from 'most'\n\nhold(periodic(10, 1)\n    .take(5)\n    .scan((total, increment) => total + increment, 0))\n    .observe(x => console.log(x))\n")),Object(i.b)("h4",{id:"multiple-arguments"},"Multiple arguments"),Object(i.b)("p",null,"Multiple arguments should be handled via partial application of the function passed to thru, using ",Object(i.b)("inlineCode",{parentName:"p"},"bind")," or a currying or partial application utility from your favorite functional programming library."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Via curried transform\nconst transform = curry((x, y, z, stream) => /* ... */)\n\nconst stream2 = stream1.thru(transform(x, y, z))\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Via partial application\nconst transform = (x, y, z, stream) => // ...\n\n// Partially apply with partial application helper\nconst stream2 = stream1.thru(partial(transform, x, y, z))\n\n// Or, partially apply with bind\nconst stream2 = stream1.thru(transform.bind(null, x, y, z)))\n")),Object(i.b)("h2",{id:"consuming-streams"},"Consuming streams"),Object(i.b)("h3",{id:"reduce"},"reduce"),Object(i.b)("h4",{id:"streamreducef-initial---promise"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.reduce(f, initial) -> Promise")),Object(i.b)("h4",{id:"mostreducef-initial-stream---promise"},Object(i.b)("inlineCode",{parentName:"h4"},"most.reduce(f, initial, stream) -> Promise")),Object(i.b)("p",null,"Reduce a stream, returning a promise for the ultimate result."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:                -1-2-3-4-|\nstream.reduce(sum, 0):           10\n")),Object(i.b)("p",null,"The returned promise will fulfill with the final reduced result, or will reject if a failure occurs while reducing the stream."),Object(i.b)("p",null,"The reduce function (",Object(i.b)("inlineCode",{parentName:"p"},"f")," above)"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"TODO: Example")),Object(i.b)("h3",{id:"observe"},"observe"),Object(i.b)("p",null,"Alias: ",Object(i.b)("strong",{parentName:"p"},"forEach")),Object(i.b)("h4",{id:"streamobservef---promise"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.observe(f) -> Promise")),Object(i.b)("h4",{id:"streamforeachf---promise"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.forEach(f) -> Promise")),Object(i.b)("h4",{id:"mostobservef-stream---promise"},Object(i.b)("inlineCode",{parentName:"h4"},"most.observe(f, stream) -> Promise")),Object(i.b)("h4",{id:"mostforeachf-stream---promise"},Object(i.b)("inlineCode",{parentName:"h4"},"most.forEach(f, stream) -> Promise")),Object(i.b)("p",null,"Start consuming events from ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),", processing each with ",Object(i.b)("inlineCode",{parentName:"p"},"f"),".  The returned promise will fulfill after all the events have been consumed, or will reject if the stream fails and the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#handling-errors"}),"error is not handled"),"."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"forEach")," alias is compatible with the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/zenparsing/es-observable#api"}),"draft ES Observable proposal ",Object(i.b)("inlineCode",{parentName:"a"},"forEach")),". Read more about ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#es-observable-interop"}),"Observable interop here"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// Log mouse movements until the user clicks, then stop.\nmost.fromEvent('mousemove', document)\n    .takeUntil(most.fromEvent('click', document))\n    .observe(x => console.log(x))\n    .then(() => console.log('All done'))\n")),Object(i.b)("h3",{id:"drain"},"drain"),Object(i.b)("h4",{id:"streamdrain---promise"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.drain() -> Promise")),Object(i.b)("h4",{id:"mostdrainstream---promise"},Object(i.b)("inlineCode",{parentName:"h4"},"most.drain(stream) -> Promise")),Object(i.b)("p",null,"Start consuming events from ",Object(i.b)("inlineCode",{parentName:"p"},"stream"),".  This can be useful in some cases where you don't want or need to process the terminal events--e.g. when all processing has been done via upstream side-effects.  Most times, however, you'll use ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#observe"}),Object(i.b)("inlineCode",{parentName:"a"},"observe"))," to consume ",Object(i.b)("em",{parentName:"p"},"and process")," terminal events."),Object(i.b)("p",null,"The returned promise will fulfill after all the events have been consumed, or will reject if the stream fails and the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#handling-errors"}),"error is not handled"),"."),Object(i.b)("h3",{id:"subscribe"},"subscribe"),Object(i.b)("h4",{id:"streamsubscribeobserver---subscription"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.subscribe(Observer) -> Subscription")),Object(i.b)("p",null,"Draft ES Observable compatible subscribe.  Start consuming events from ",Object(i.b)("inlineCode",{parentName:"p"},"stream")," by providing an ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/zenparsing/es-observable#observer"}),"Observer object"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"type Observer = {\n  // Receives the next value in the sequence\n  next(value) => void\n  // Receives the sequence error\n  error(errorValue) => void\n  // Receives the sequence completion signal\n  // The completionValue parameter is deprecated\n  complete(completionValue) => void\n}\n")),Object(i.b)("p",null,"Returns a ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/zenparsing/es-observable#api"}),"Subscription object")," that can be used to unsubscribe from the stream of events."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"type Subscription = {\n    // Cancels the subscription\n    unsubscribe() => void\n}\n")),Object(i.b)("p",null,"Read more about ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#draft-es-observable-interop"}),"draft ES Observable interop here"),"."),Object(i.b)("h3",{id:"observeforeach-or-subscribe"},Object(i.b)("inlineCode",{parentName:"h3"},"observe"),"/",Object(i.b)("inlineCode",{parentName:"h3"},"forEach")," or ",Object(i.b)("inlineCode",{parentName:"h3"},"subscribe")),Object(i.b)("p",null,"Both ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#observe"}),Object(i.b)("inlineCode",{parentName:"a"},"forEach"))," and ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#subscribe"}),Object(i.b)("inlineCode",{parentName:"a"},"subscribe"))," are supported in the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/zenparsing/es-observable"}),"draft ES Observable proposal"),", and the following behave similarly:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"stream.forEach(handleEvent).then(handleEnd, handleError)\n\nstream.subscribe({\n    next: handleEvent,\n    complete: handleEnd,\n    error: handleError\n})\n")),Object(i.b)("p",null,"However, there are also some important differences."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"forEach"))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"returns a Promise, which can be transformed further using ",Object(i.b)("inlineCode",{parentName:"li"},".then"),","),Object(i.b)("li",{parentName:"ul"},"integrates easily into existing asynchronous code that uses promises"),Object(i.b)("li",{parentName:"ul"},"encourages declarative programming using ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#until"}),Object(i.b)("inlineCode",{parentName:"a"},"until")),", ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#take"}),Object(i.b)("inlineCode",{parentName:"a"},"take")),", and ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#takeWhile"}),Object(i.b)("inlineCode",{parentName:"a"},"takeWhile")),", etc.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"subscribe"))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"returns a ",Object(i.b)("inlineCode",{parentName:"li"},"Subscription"),","),Object(i.b)("li",{parentName:"ul"},"allows imperative unsubscription in cases where declarative isn't possible")),Object(i.b)("h2",{id:"combining-streams"},"Combining streams"),Object(i.b)("h3",{id:"merge"},"merge"),Object(i.b)("h4",{id:"stream1mergestream2---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream1.merge(stream2) -> Stream")),Object(i.b)("h4",{id:"mostmergestream1-stream2---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.merge(stream1, stream2) -> Stream")),Object(i.b)("p",null,"Create a new stream containing events from ",Object(i.b)("inlineCode",{parentName:"p"},"stream1")," and ",Object(i.b)("inlineCode",{parentName:"p"},"stream2"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream1:                -a--b----c---\x3e\nstream2:                --w---x-y--z->\nstream1.merge(stream2): -aw-b-x-yc-z->\n")),Object(i.b)("p",null,"Merging multiple streams creates a new stream containing all events from the input stream without affecting the arrival time of the events.  You can think of the events from the input streams simply being interleaved into the new, merged stream.  A merged stream ends when ",Object(i.b)("em",{parentName:"p"},"all")," of its input streams have ended."),Object(i.b)("p",null,"In contrast to ",Object(i.b)("inlineCode",{parentName:"p"},"concat"),", ",Object(i.b)("inlineCode",{parentName:"p"},"merge")," preserves the arrival times of events. That is, it creates a new stream where events from ",Object(i.b)("inlineCode",{parentName:"p"},"stream1")," and ",Object(i.b)("inlineCode",{parentName:"p"},"stream2")," can interleave."),Object(i.b)("h3",{id:"mergearray"},"mergeArray"),Object(i.b)("h4",{id:"mostmergearrayarrayofstreams---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.mergeArray(arrayOfStreams) -> Stream")),Object(i.b)("p",null,"Array form of ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#merge"}),"merge"),".  Create a new Stream containing all events from all streams in ",Object(i.b)("inlineCode",{parentName:"p"},"arrayOfStreams"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"s1:                             -a--b----c---\x3e\ns2:                             --w---x-y--z->\ns3:                             ---1---2----3>\nmost.mergeArray([s1, s2, s3]):  -aw1b-x2yc-z3>\n")),Object(i.b)("p",null,"See ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#merge"}),"merge")," for more details."),Object(i.b)("h3",{id:"combine"},"combine"),Object(i.b)("h4",{id:"stream1combinef-stream2---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream1.combine(f, stream2) -> Stream")),Object(i.b)("h4",{id:"mostcombinef-stream1-stream2---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.combine(f, stream1, stream2) -> Stream")),Object(i.b)("p",null,"Create a new stream that emits the set of latest event values from all input streams whenever a new event arrives on any input stream."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream1:                       -0--1----2---\x3e\nstream2:                       --3---4-5--6->\nstream1.combine(add, stream2): --3-4-5-67-8->\n")),Object(i.b)("p",null,"Combining creates a new stream by applying a function to the most recent event from each stream whenever a new event arrives on any one stream.  Combining must wait for at least one event to arrive on all input streams before it can produce any events."),Object(i.b)("p",null,"A combined stream has the same proportion as the max of the proportions of its input streams. To put it imperative terms: combine ends after all its inputs have ended."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Add the current value of two inputs\n// Updates the result whenever *either* of the inputs changes!\n\n// Create a stream from an <input> value\nconst fromInput = input =>\n    most.fromEvent('change', input)\n        .map(e => e.target.value)\n        .map(Number)\n\n// Add two numbers\nconst add = (x, y) => x + y\n\n// Create streams for the current value of x and y\nconst xStream = fromInput(document.querySelector('input.x'))\nconst yStream = fromInput(document.querySelector('input.y'))\n\n// Create a result stream by adding x and y\n// This always adds the latest value of x and y\nconst resultStream = most.combine(add, xStream, yStream)\n\nconst resultNode = document.querySelector('.result')\nresultStream.observe(z => {\n    resultNode.textContent = z\n})\n")),Object(i.b)("h3",{id:"combinearray"},"combineArray"),Object(i.b)("h4",{id:"mostcombinearrayf-arrayofstreams---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.combineArray(f, arrayOfStreams) -> Stream")),Object(i.b)("p",null,"Array form of ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#combine"}),"combine"),". Create a new stream that emits the set of latest event values from all input streams whenever a new event arrives on any input stream."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"s1:                                    -0--1----2->\ns2:                                    --3---4-5--\x3e\ns3:                                    ---2---1---\x3e\nmost.combineArray(add3, [s1, s2, s3]): ---56-7678->\n")),Object(i.b)("p",null,"See ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#combine"}),"combine")," for more details."),Object(i.b)("h3",{id:"sample"},"sample"),Object(i.b)("h4",{id:"samplersamplef-streams---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"sampler.sample(f, ...streams) -> Stream")),Object(i.b)("h4",{id:"mostsamplef-sampler-streams---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.sample(f, sampler, ...streams) -> Stream")),Object(i.b)("p",null,"Create a new stream by combining sampled values from many input streams."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"s1:                          -1-----2-----3->\ns2:                          -1---2---3---4->\nsampler:                     -a-a-a-a-a-a-a->\nsampler.sample(add, s1, s2): -2-2-3-4-5-5-7->\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"s1:                          -1----2----3->\ns2:                          -1-2-3-4-5-6->\nsampler:                     -a--a--a--a--\x3e\nsampler.sample(add, s1, s2): -2--3--6--7--\x3e\n")),Object(i.b)("p",null,"While ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#combine"}),Object(i.b)("inlineCode",{parentName:"a"},"combine")),", produces a value whenever an event arrives on any of its inputs, ",Object(i.b)("inlineCode",{parentName:"p"},"sample")," produces a value only when an event arrives on the sampler."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// Add the current value of two inputs\n// Updates only when the user clicks a button\n\n// Create a stream from an <input> value\nconst fromInput = input =>\n    most.fromEvent('change', input)\n        .map(e => e.target.value)\n        .map(Number)\n\n// Add two numbers\nconst add = (x, y) => x + y\n\n// Create streams for the current value of x and y\nconst xStream = fromInput(document.querySelector('input.x'))\nconst yStream = fromInput(document.querySelector('input.y'))\n\nconst click = most.fromEvent('click', document.querySelector('.button'))\n\n// Create a result stream by adding the values of x and y\n// at the time the button was clicked.\n// NOTE: add() is NOT called when x and y change, but rather\n// only when the button is clicked.\nconst resultStream = most.sample(add, click, xStream, yStream)\n\nconst resultNode = document.querySelector('.result')\nresultStream.observe(z => {\n    resultNode.textContent = z\n})\n")),Object(i.b)("h3",{id:"samplewith"},"sampleWith"),Object(i.b)("h4",{id:"valuessamplewithsampler---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"values.sampleWith(sampler) -> Stream")),Object(i.b)("h4",{id:"mostsamplewithsampler-values---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.sampleWith(sampler, values) -> Stream")),Object(i.b)("p",null,"When an event arrives on sampler, emit the latest event value from values.  Effectively equivalent to ",Object(i.b)("inlineCode",{parentName:"p"},"sampler.sample(identity, values);")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"values:                     -1---2-3---4-5---6-7---8->\nsampler:                    ---a---a---a---a---a---a->\nvalues.sampleWith(sampler): ---1---3---4---5---7---8->\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"values:                     -1----2----3----4----5---\x3e\nsampler:                    -a-a-a-a-a-a-a-a-a-a-a-a->\nvalues.sampleWith(sampler): -1-1-1-2-2-3-3-3-4-4-5-5->\n")),Object(i.b)("p",null,'Sampling can "smooth" an erratic source, or can act as a dynamic throttle to speed or slow events from one stream using another.'),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// Log mouse position whenever the user presses a key\nmost.fromEvent('mousemove', document)\n    .sampleWith(most.fromEvent('keydown', document))\n    .observe(console.log.bind(console));\n")),Object(i.b)("h3",{id:"zip"},"zip"),Object(i.b)("h4",{id:"stream1zipf-stream2---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream1.zip(f, stream2) -> Stream")),Object(i.b)("h4",{id:"mostzipf-stream1-stream2---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.zip(f, stream1, stream2) -> Stream")),Object(i.b)("p",null,"Create a new stream by applying a function to corresponding pairs of events from the inputs streams."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream1:                   -1--2--3--4->\nstream2:                   -1---2---3---4->\nstream1.zip(add, stream2): -2---4---6---8->\n")),Object(i.b)("p",null,"Zipping correlates ",Object(i.b)("em",{parentName:"p"},"by index"),' corresponding events from two or more input streams.  Note that zipping a "fast" stream and a "slow" stream will cause buffering.  Events from the fast stream must be buffered in memory until an event at the corresponding index arrives on the slow stream.'),Object(i.b)("p",null,"A zipped stream ends when any one of its input streams ends."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"const add = (x, y) => x + y\n\n// Logs 5 7 9\n// In other words: add(1, 4) add(2, 5) add(3, 6)\nmost.from([1,2,3])\n    .zip(add, most.from([4,5,6,7,8]))\n    .forEach(x => console.log(x))\n")),Object(i.b)("p",null,"A stream zipped with a stream created by ",Object(i.b)("inlineCode",{parentName:"p"},"most.periodic")," will emit events in intervals."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"// Logs new sum every second\nmost.from([1, 2, 3, 4])\n    .zip(v => v, most.periodic(1000))\n    .scan((result, y) => result + y, 0)\n    .forEach(x => console.log(x))\n")),Object(i.b)("h2",{id:"combining-higher-order-streams"},"Combining higher-order streams"),Object(i.b)("h3",{id:"switchlatest"},"switchLatest"),Object(i.b)("p",null,"Alias: ",Object(i.b)("strong",{parentName:"p"},"switch")),Object(i.b)("h4",{id:"streamswitchlatest---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.switchLatest() -> Stream")),Object(i.b)("h4",{id:"mostswitchlateststream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.switchLatest(stream) -> Stream")),Object(i.b)("p",null,"Given a ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/cujojs/most/wiki/Concepts#higher-order-streams"}),"higher-order stream"),", return a new stream that adopts the behavior of (ie emits the events of) the most recent inner stream."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"s:                     -a-b-c-d-e-f->\nt:                     -1-2-3-4-5-6->\nstream:                -s-----t-----\x3e\nstream.switchLatest(): -a-b-c-4-5-6->\n")),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"TODO: Example")),Object(i.b)("h3",{id:"join"},"join"),Object(i.b)("h4",{id:"streamjoin---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.join() -> Stream")),Object(i.b)("h4",{id:"mostjoinstream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.join(stream) -> Stream")),Object(i.b)("p",null,"Given a ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/cujojs/most/wiki/Concepts#higher-order-streams"}),"higher-order stream"),", return a new stream that merges all the inner streams as they arrive."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"s:             ---a---b---c---d--\x3e\nt:             -1--2--3--4--5--6->\nstream:        -s------t---------\x3e\nstream.join(): ---a---b--4c-5-d6->\n")),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"TODO: Example")),Object(i.b)("h3",{id:"mergeconcurrently"},"mergeConcurrently"),Object(i.b)("h4",{id:"streammergeconcurrentlyconcurrency---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.mergeConcurrently(concurrency) -> Stream")),Object(i.b)("h4",{id:"mostmergeconcurrentlyconcurrency-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.mergeConcurrently(concurrency, stream) -> Stream")),Object(i.b)("p",null,"Given a ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/cujojs/most/wiki/Concepts#higher-order-streams"}),"higher-order stream"),", return a new stream that merges inner streams as they arrive ",Object(i.b)("em",{parentName:"p"},"up to the specified concurrency"),".  Once ",Object(i.b)("inlineCode",{parentName:"p"},"concurrency")," number of streams are being merged, newly arriving streams will be merged after an existing one ends."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"s:                           --a--b--c--d--e--\x3e\nt:                           --x------y|\nu:                           -1--2--3--4--5--6>\nstream:                      -s--t--u---------\x3e\nstream.mergeConcurrently(2): --a--b--cy4d-5e-6>\n")),Object(i.b)("p",null,"Note that ",Object(i.b)("inlineCode",{parentName:"p"},"u")," is only merged ",Object(i.b)("em",{parentName:"p"},"after")," ",Object(i.b)("inlineCode",{parentName:"p"},"t")," ends, due to the concurrency level of ",Object(i.b)("inlineCode",{parentName:"p"},"2"),"."),Object(i.b)("p",null,"Note also that ",Object(i.b)("inlineCode",{parentName:"p"},"stream.mergeConcurrently(Infinity)")," is equivalent to ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#join"}),Object(i.b)("inlineCode",{parentName:"a"},"stream.join()")),"."),Object(i.b)("p",null,"To control concurrency, ",Object(i.b)("inlineCode",{parentName:"p"},"mergeConcurrently")," must maintain an internal queue of newly arrived streams.  If new streams arrive faster than the concurrency level allows them to be merged, the internal queue will grow infinitely."),Object(i.b)("h2",{id:"awaiting-promises"},"Awaiting promises"),Object(i.b)("h3",{id:"awaitpromises"},"awaitPromises"),Object(i.b)("p",null,"Deprecated alias: ",Object(i.b)("inlineCode",{parentName:"p"},"await")),Object(i.b)("h4",{id:"streamawaitpromises---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.awaitPromises() -> Stream")),Object(i.b)("h4",{id:"mostawaitpromisesstream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.awaitPromises(stream) -> Stream")),Object(i.b)("p",null,"Given a stream of promises, ie Stream","<","Promise","<","X",">",">",", return a new stream containing the fulfillment values, ie Stream","<","X",">","."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"promise p:              ---1\npromise q:              ------2\npromise r:              -3\nstream:                 -p---q---r->\nstream.awaitPromises(): ---1--2--3->\n")),Object(i.b)("p",null,"Event ",Object(i.b)("em",{parentName:"p"},"times")," may be delayed.  However, event ",Object(i.b)("em",{parentName:"p"},"order")," is always preserved, regardless of promise fulfillment order."),Object(i.b)("p",null,"To create a stream that merges promises in fulfillment order, use\n",Object(i.b)("inlineCode",{parentName:"p"},"stream.chain(most.fromPromise)"),".  Note the difference:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"promise p:                        --1\npromise q:                        --------2\npromise r:                        ------3\nstream:                           -p-q-r-----\x3e\nstream.chain(most.fromPromise):   --1---3-2--\x3e\nstream.awaitPromises():           --1-----23->\n")),Object(i.b)("p",null,"If a promise rejects, the stream will be in an error state with the rejected promise's reason as its error.  See ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#recoverwith"}),"recoverWith")," for error recovery.  For example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"promise p:              ---1\npromise q:              ------X\npromise r:              -3\nstream:                 -p---q---r->\nstream.awaitPromises(): ---1--X\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"const urls = ['http://...', 'http://...', 'http://...']\n\nconst fetchContent = url => {\n   // ... fetch url and return a promise for it ...\n   //\n   return Promise.resolve(url)\n}\n\nconst streamOfPromises = most.from(urls).map(fetchContent)\n\nconst streamOfContent = streamOfPromises.await()\n\nstreamOfContent.forEach(content => console.log(content))\n")),Object(i.b)("h2",{id:"rate-limiting-streams"},"Rate limiting streams"),Object(i.b)("h3",{id:"debounce"},"debounce"),Object(i.b)("h4",{id:"streamdebouncedebouncetime---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.debounce(debounceTime) -> Stream")),Object(i.b)("h4",{id:"mostdebouncedebouncetime-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.debounce(debounceTime, stream) -> Stream")),Object(i.b)("p",null,"Wait for a burst of events to subside and emit only the last event in the burst."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:             abcd----abcd----\x3e\nstream.debounce(2): -----d-------d--\x3e\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"s1:                       abcd----abcd----\x3e\ns2:                       ------------|\ns1.until(s2).debounce(2): -----d------d|\n")),Object(i.b)("p",null,"If the stream ends while there is a pending debounced event (e.g. via ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#until"}),Object(i.b)("inlineCode",{parentName:"a"},"until")),", see example above), the pending event will be emitted just before the stream ends."),Object(i.b)("p",null,"Debouncing can be extremely useful when dealing with bursts of similar events, for example, debouncing keypress events before initiating a remote search query in a browser application."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-es6"}),"const searchInput = document.querySelector('[name=\"search-text\"]');\nconst searchText = most.fromEvent('input', searchInput);\n\n// Logs the current value of the searchInput, only after the\n// user stops typing for 500 millis\nsearchText.debounce(500)\n    .map(e => e.target.value)\n    .observe(x => console.log(x));\n")),Object(i.b)("h3",{id:"throttle"},"throttle"),Object(i.b)("h4",{id:"streamthrottlethrottleperiod---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.throttle(throttlePeriod) -> Stream")),Object(i.b)("h4",{id:"mostthrottlethrottleperiod-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.throttle(throttlePeriod, stream) -> Stream")),Object(i.b)("p",null,"Limit the rate of events to at most one per throttlePeriod."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:              abcd----abcd----\x3e\nstream.throttle(2):  a-c-----a-c-----\x3e\n")),Object(i.b)("p",null,"In contrast to debounce, throttle simply drops events that occur more often than ",Object(i.b)("inlineCode",{parentName:"p"},"throttlePeriod"),', whereas debounce waits for a "quiet period".'),Object(i.b)("h2",{id:"delaying-streams"},"Delaying streams"),Object(i.b)("h3",{id:"delay"},"delay"),Object(i.b)("h4",{id:"streamdelaydelaytime---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.delay(delayTime) -> Stream")),Object(i.b)("h4",{id:"mostdelaydelaytime-stream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.delay(delayTime, stream) -> Stream")),Object(i.b)("p",null,"Timeshift a ",Object(i.b)("inlineCode",{parentName:"p"},"stream")," by ",Object(i.b)("inlineCode",{parentName:"p"},"delayTime"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:          -a-b-c-d->\nstream.delay(1): --a-b-c-d->\nstream.delay(5): ------a-b-c-d->\n")),Object(i.b)("p",null,"Delaying a stream timeshifts all the events by the same amount.  Delaying doesn't change the time ",Object(i.b)("em",{parentName:"p"},"between")," events."),Object(i.b)("h2",{id:"sharing-streams"},"Sharing streams"),Object(i.b)("h3",{id:"multicast"},"multicast"),Object(i.b)("h4",{id:"streammulticast---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"stream.multicast() -> Stream")),Object(i.b)("h4",{id:"mostmulticaststream---stream"},Object(i.b)("inlineCode",{parentName:"h4"},"most.multicast(stream) -> Stream")),Object(i.b)("p",null,"Returns a stream equivalent to the original, but which can be shared more efficiently among multiple consumers."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"stream:             -a-b-c-d->\nstream.multicast(): -a-b-c-d->\n")),Object(i.b)("p",null,"Using ",Object(i.b)("inlineCode",{parentName:"p"},"multicast")," allows you to build up a stream of maps, filters, and other transformations, and then share it efficiently with multiple observers."))}o.isMDXComponent=!0},73:function(e,t,a){"use strict";a.d(t,"a",(function(){return l})),a.d(t,"b",(function(){return u}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function b(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var m=r.a.createContext({}),o=function(e){var t=r.a.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):b(b({},t),e)),a},l=function(e){var t=o(e.components);return r.a.createElement(m.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,m=c(e,["components","mdxType","originalType","parentName"]),l=o(a),d=n,u=l["".concat(s,".").concat(d)]||l[d]||p[d]||i;return a?r.a.createElement(u,b(b({ref:t},m),{},{components:a})):r.a.createElement(u,b({ref:t},m))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,s=new Array(i);s[0]=d;var b={};for(var c in t)hasOwnProperty.call(t,c)&&(b[c]=t[c]);b.originalType=e,b.mdxType="string"==typeof e?e:n,s[1]=b;for(var m=2;m<i;m++)s[m]=a[m];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,a)}d.displayName="MDXCreateElement"}}]);