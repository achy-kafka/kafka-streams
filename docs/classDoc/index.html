<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus v2.0.0-alpha.61">
<title data-react-helmet="true">Class Documentation | Kafka streams</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Class Documentation | Kafka streams"><meta data-react-helmet="true" name="description" content="Summary"><meta data-react-helmet="true" property="og:description" content="Summary"><meta data-react-helmet="true" property="og:url" content="https://nodefluent.github.io/docs/classDoc"><link data-react-helmet="true" rel="shortcut icon" href="/🐙"><link data-react-helmet="true" rel="canonical" href="https://nodefluent.github.io/docs/classDoc"><link rel="stylesheet" href="/styles.ad8305e2.css">
<link rel="preload" href="/styles.1a871891.js" as="script">
<link rel="preload" href="/runtime~main.e81608d8.js" as="script">
<link rel="preload" href="/main.5ae6171e.js" as="script">
<link rel="preload" href="/1.c9d93e90.js" as="script">
<link rel="preload" href="/2.2ed3b975.js" as="script">
<link rel="preload" href="/16.82e5cb28.js" as="script">
<link rel="preload" href="/17.6c960b8e.js" as="script">
<link rel="preload" href="/20ac7829.45d0d2b4.js" as="script">
<link rel="preload" href="/17896441.92507d38.js" as="script">
<link rel="preload" href="/9f1a437a.f26d39ae.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">Kafka Streams 🐙</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/nodefluent/kafka-streams" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">Kafka Streams 🐙</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">Docs</a></li><li class="menu__list-item"><a href="https://github.com/nodefluent/kafka-streams" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Usage</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/">Quick Start Tutorial</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/handlingMessageSchemas">Message &#x27;to&#x27; and &#x27;from&#x27; Apache Kafka</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/ksAPI">API info</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mostAPI">Operator descriptions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/native">Native Consumer/Producer Explanation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sslSasl">SSL, SASL and Kerberos Support</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/classDoc">Class Documentation</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Class Documentation</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="summary"></a>Summary<a aria-hidden="true" tabindex="-1" class="hash-link" href="#summary" title="Direct link to heading">#</a></h2><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td><a href="#keycount">KeyCount</a></td><td>used to count keys in a stream</td></tr><tr><td><a href="#laststate">LastState</a></td><td>used to hold the last state of key values in a stream e.g. building KTables</td></tr><tr><td><a href="#max">Max</a></td><td>used to grab the highest value of key values in a stream</td></tr><tr><td><a href="#min">Min</a></td><td>used grab the lowest value of key values in a stream</td></tr><tr><td><a href="#sum">Sum</a></td><td>used to sum up key values in a stream</td></tr><tr><td><a href="#window">Window</a></td><td>used to build windows of key value states in a stream</td></tr><tr><td><a href="#jskafkaclient">JSKafkaClient</a></td><td></td></tr><tr><td><a href="#nativekafkaclient">NativeKafkaClient</a></td><td></td></tr><tr><td><a href="#kstream">KStream</a></td><td>change-log representation of a stream</td></tr><tr><td><a href="#ktable">KTable</a></td><td>table representation of a stream</td></tr><tr><td><a href="#streamdsl">StreamDSL</a></td><td>Stream base class</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="keycount"></a>KeyCount<a aria-hidden="true" tabindex="-1" class="hash-link" href="#keycount" title="Direct link to heading">#</a></h2><p>used to count keys in a stream</p><p><strong>Kind</strong>: global class  </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="laststate"></a>LastState<a aria-hidden="true" tabindex="-1" class="hash-link" href="#laststate" title="Direct link to heading">#</a></h2><p>used to hold the last state of key values
in a stream e.g. building KTables</p><p><strong>Kind</strong>: global class  </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="max"></a>Max<a aria-hidden="true" tabindex="-1" class="hash-link" href="#max" title="Direct link to heading">#</a></h2><p>used to grab the highest value of key values
in a stream</p><p><strong>Kind</strong>: global class  </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="min"></a>Min<a aria-hidden="true" tabindex="-1" class="hash-link" href="#min" title="Direct link to heading">#</a></h2><p>used grab the lowest value of
key values in a stream</p><p><strong>Kind</strong>: global class  </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="sum"></a>Sum<a aria-hidden="true" tabindex="-1" class="hash-link" href="#sum" title="Direct link to heading">#</a></h2><p>used to sum up key values in a stream</p><p><strong>Kind</strong>: global class  </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="window"></a>Window<a aria-hidden="true" tabindex="-1" class="hash-link" href="#window" title="Direct link to heading">#</a></h2><p>used to build windows of key value states
in a stream</p><p><strong>Kind</strong>: global class  </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="jskafkaclient"></a>JSKafkaClient<a aria-hidden="true" tabindex="-1" class="hash-link" href="#jskafkaclient" title="Direct link to heading">#</a></h2><p><strong>Kind</strong>: global class  </p><ul><li><a href="#jskafkaclient">JSKafkaClient</a><ul><li><a href="#new_jskafkaclient_new">new JSKafkaClient(topic, config)</a></li><li><a href="#jskafkaclient+setproducehandler">.setProduceHandler(handler)</a></li><li><a href="#jskafkaclient+getproducehandler">.getProduceHandler()</a> ⇒ <code>null</code> | <code>EventEmitter</code></li><li><a href="#jskafkaclient+overwritetopics">.overwriteTopics(topics)</a></li><li><a href="#jskafkaclient+start">.start(readyCallback, kafkaErrorCallback, withProducer, withBackPressure)</a></li><li><a href="#jskafkaclient+setupproducer">.setupProducer(produceTopic, partitions, readyCallback, kafkaErrorCallback, outputKafkaConfig)</a></li><li><a href="#jskafkaclient+send">.send(topic, message)</a> ⇒ <code>\*</code></li><li><a href="#jskafkaclient+buffer">.buffer(topic, identifier, payload, compressionType)</a> ⇒ <code>\*</code></li><li><a href="#jskafkaclient+bufferformat">.bufferFormat(topic, identifier, payload, version, compressionType)</a> ⇒ <code>\*</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="new-jskafkaclienttopic-config"></a>new JSKafkaClient(topic, config)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#new-jskafkaclienttopic-config" title="Direct link to heading">#</a></h3><p>KafkaClient (EventEmitter)
that wraps an internal instance of a
Sinek kafka- Consumer and/or Producer</p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>topic</td></tr><tr><td>config</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="jskafkaclientsetproducehandlerhandler"></a>jsKafkaClient.setProduceHandler(handler)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#jskafkaclientsetproducehandlerhandler" title="Direct link to heading">#</a></h3><p>sets a handler for produce messages
(emits whenever kafka messages are produced/delivered)</p><p><strong>Kind</strong>: instance method of <a href="#jskafkaclient"><code>JSKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>handler</td><td><code>EventEmitter</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="jskafkaclientgetproducehandler-⇒-null--eventemitter"></a>jsKafkaClient.getProduceHandler() ⇒ <code>null</code> | <code>EventEmitter</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#jskafkaclientgetproducehandler-⇒-null--eventemitter" title="Direct link to heading">#</a></h3><p>returns the produce handler instance if present</p><p><strong>Kind</strong>: instance method of <a href="#jskafkaclient"><code>JSKafkaClient</code></a>  </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="jskafkaclientoverwritetopicstopics"></a>jsKafkaClient.overwriteTopics(topics)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#jskafkaclientoverwritetopicstopics" title="Direct link to heading">#</a></h3><p>overwrites the topic</p><p><strong>Kind</strong>: instance method of <a href="#jskafkaclient"><code>JSKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>topics</td><td><code>Array.&amp;lt;string&amp;gt;</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="jskafkaclientstartreadycallback-kafkaerrorcallback-withproducer-withbackpressure"></a>jsKafkaClient.start(readyCallback, kafkaErrorCallback, withProducer, withBackPressure)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#jskafkaclientstartreadycallback-kafkaerrorcallback-withproducer-withbackpressure" title="Direct link to heading">#</a></h3><p>starts a new kafka consumer (using sinek&#x27;s partition drainer)
will await a kafka-producer-ready-event if started withProducer=true</p><p><strong>Kind</strong>: instance method of <a href="#jskafkaclient"><code>JSKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>readyCallback</td><td></td></tr><tr><td>kafkaErrorCallback</td><td></td></tr><tr><td>withProducer</td><td><code>false</code></td></tr><tr><td>withBackPressure</td><td><code>false</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="jskafkaclientsetupproducerproducetopic-partitions-readycallback-kafkaerrorcallback-outputkafkaconfig"></a>jsKafkaClient.setupProducer(produceTopic, partitions, readyCallback, kafkaErrorCallback, outputKafkaConfig)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#jskafkaclientsetupproducerproducetopic-partitions-readycallback-kafkaerrorcallback-outputkafkaconfig" title="Direct link to heading">#</a></h3><p>starts a new kafka-producer using sinek&#x27;s publisher
will fire kafka-producer-ready-event
requires a topic&#x27;s partition count during initialisation</p><p><strong>Kind</strong>: instance method of <a href="#jskafkaclient"><code>JSKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>produceTopic</td><td></td></tr><tr><td>partitions</td><td><code>1</code></td></tr><tr><td>readyCallback</td><td></td></tr><tr><td>kafkaErrorCallback</td><td></td></tr><tr><td>outputKafkaConfig</td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="jskafkaclientsendtopic-message-⇒-"></a>jsKafkaClient.send(topic, message) ⇒ <code>*</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#jskafkaclientsendtopic-message-⇒-" title="Direct link to heading">#</a></h3><p>simply produces a message or multiple on a topic
if producerPartitionCount is &gt; 1 it will randomize
the target partition for the message/s</p><p><strong>Kind</strong>: instance method of <a href="#jskafkaclient"><code>JSKafkaClient</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>topic</td></tr><tr><td>message</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="jskafkaclientbuffertopic-identifier-payload-compressiontype-⇒-"></a>jsKafkaClient.buffer(topic, identifier, payload, compressionType) ⇒ <code>*</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#jskafkaclientbuffertopic-identifier-payload-compressiontype-⇒-" title="Direct link to heading">#</a></h3><p>buffers a keyed message to be send
a keyed message needs an identifier, if none is provided
an uuid.v4() will be generated</p><p><strong>Kind</strong>: instance method of <a href="#jskafkaclient"><code>JSKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>topic</td><td></td></tr><tr><td>identifier</td><td></td></tr><tr><td>payload</td><td></td></tr><tr><td>compressionType</td><td><code>0</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="jskafkaclientbufferformattopic-identifier-payload-version-compressiontype-⇒-"></a>jsKafkaClient.bufferFormat(topic, identifier, payload, version, compressionType) ⇒ <code>*</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#jskafkaclientbufferformattopic-identifier-payload-version-compressiontype-⇒-" title="Direct link to heading">#</a></h3><p>buffers a keyed message in (a base json format) to be send
a keyed message needs an identifier, if none is provided
an uuid.4() will be generated</p><p><strong>Kind</strong>: instance method of <a href="#jskafkaclient"><code>JSKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>topic</td><td></td></tr><tr><td>identifier</td><td></td></tr><tr><td>payload</td><td></td></tr><tr><td>version</td><td><code>1</code></td></tr><tr><td>compressionType</td><td><code>0</code></td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nativekafkaclient"></a>NativeKafkaClient<a aria-hidden="true" tabindex="-1" class="hash-link" href="#nativekafkaclient" title="Direct link to heading">#</a></h2><p><strong>Kind</strong>: global class  </p><ul><li><a href="#nativekafkaclient">NativeKafkaClient</a><ul><li><a href="#new_nativekafkaclient_new">new NativeKafkaClient(topic, config, batchOptions)</a></li><li><a href="#nativekafkaclient+setproducehandler">.setProduceHandler(handler)</a></li><li><a href="#nativekafkaclient+getproducehandler">.getProduceHandler()</a> ⇒ <code>null</code> | <code>EventEmitter</code></li><li><a href="#nativekafkaclient+overwritetopics">.overwriteTopics(topics)</a></li><li><a href="#nativekafkaclient+start">.start(readyCallback, kafkaErrorCallback, withProducer, withBackPressure)</a></li><li><a href="#Nativekafkaclient+setupproducer">.setupProducer(produceTopic, partitions, readyCallback, kafkaErrorCallback, outputKafkaConfig)</a></li><li><a href="#nativekafkaclient+send">.send(topicName, message, partition, key, partitionKey, opaqueKey)</a> ⇒ <code>Promise.&amp;lt;void&amp;gt;</code></li><li><a href="#nativekafkaclient+buffer">.buffer(topic, identifier, payload, _, partition, version, partitionKey)</a> ⇒ <code>Promise.&amp;lt;void&amp;gt;</code></li><li><a href="#nativekafkaclient+bufferformat">.bufferFormat(topic, identifier, payload, version, _, partitionKey, partition)</a> ⇒ <code>Promise.&amp;lt;void&amp;gt;</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="new-nativekafkaclienttopic-config-batchoptions"></a>new NativeKafkaClient(topic, config, batchOptions)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#new-nativekafkaclienttopic-config-batchoptions" title="Direct link to heading">#</a></h3><p>NativeKafkaClient (EventEmitter)
that wraps an internal instance of a
Sinek native kafka- Consumer and/or Producer</p><table><thead><tr><th>Param</th><th>Description</th></tr></thead><tbody><tr><td>topic</td><td></td></tr><tr><td>config</td><td></td></tr><tr><td>batchOptions</td><td>optional</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nativekafkaclientsetproducehandlerhandler"></a>nativeKafkaClient.setProduceHandler(handler)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#nativekafkaclientsetproducehandlerhandler" title="Direct link to heading">#</a></h3><p>sets a handler for produce messages
(emits whenever kafka messages are produced/delivered)</p><p><strong>Kind</strong>: instance method of <a href="#nativekafkaclient"><code>NativeKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>handler</td><td><code>EventEmitter</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nativekafkaclientgetproducehandler-⇒-null--eventemitter"></a>nativeKafkaClient.getProduceHandler() ⇒ <code>null</code> | <code>EventEmitter</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#nativekafkaclientgetproducehandler-⇒-null--eventemitter" title="Direct link to heading">#</a></h3><p>returns the produce handler instance if present</p><p><strong>Kind</strong>: instance method of <a href="#nativekafkaclient"><code>NativeKafkaClient</code></a>  </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nativekafkaclientoverwritetopicstopics"></a>nativeKafkaClient.overwriteTopics(topics)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#nativekafkaclientoverwritetopicstopics" title="Direct link to heading">#</a></h3><p>overwrites the topic</p><p><strong>Kind</strong>: instance method of <a href="#nativekafkaclient"><code>NativeKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>topics</td><td><code>Array.&amp;lt;string&amp;gt;</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nativekafkaclientstartreadycallback-kafkaerrorcallback-withproducer-withbackpressure"></a>nativeKafkaClient.start(readyCallback, kafkaErrorCallback, withProducer, withBackPressure)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#nativekafkaclientstartreadycallback-kafkaerrorcallback-withproducer-withbackpressure" title="Direct link to heading">#</a></h3><p>starts a new kafka consumer
will await a kafka-producer-ready-event if started withProducer=true</p><p><strong>Kind</strong>: instance method of <a href="#nativekafkaclient"><code>NativeKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>readyCallback</td><td></td></tr><tr><td>kafkaErrorCallback</td><td></td></tr><tr><td>withProducer</td><td><code>false</code></td></tr><tr><td>withBackPressure</td><td><code>false</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nativekafkaclientsetupproducerproducetopic-partitions-readycallback-kafkaerrorcallback-outputkafkaconfig"></a>nativeKafkaClient.setupProducer(produceTopic, partitions, readyCallback, kafkaErrorCallback, outputKafkaConfig)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#nativekafkaclientsetupproducerproducetopic-partitions-readycallback-kafkaerrorcallback-outputkafkaconfig" title="Direct link to heading">#</a></h3><p>starts a new kafka-producer
will fire kafka-producer-ready-event
requires a topic&#x27;s partition count during initialisation</p><p><strong>Kind</strong>: instance method of <a href="#nativekafkaclient"><code>NativeKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>produceTopic</td><td></td></tr><tr><td>partitions</td><td><code>1</code></td></tr><tr><td>readyCallback</td><td></td></tr><tr><td>kafkaErrorCallback</td><td></td></tr><tr><td>outputKafkaConfig</td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nativekafkaclientsendtopicname-message-partition-key-partitionkey-opaquekey-⇒-promiseltvoidgt"></a>nativeKafkaClient.send(topicName, message, partition, key, partitionKey, opaqueKey) ⇒ <code>Promise.&amp;lt;void&amp;gt;</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#nativekafkaclientsendtopicname-message-partition-key-partitionkey-opaquekey-⇒-promiseltvoidgt" title="Direct link to heading">#</a></h3><p>simply produces a message or multiple on a topic
if producerPartitionCount is &gt; 1 it will randomize
the target partition for the message/s</p><p><strong>Kind</strong>: instance method of <a href="#nativekafkaclient"><code>NativeKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>topicName</td><td></td><td></td></tr><tr><td>message</td><td></td><td></td></tr><tr><td>partition</td><td></td><td>optional</td></tr><tr><td>key</td><td></td><td>optional</td></tr><tr><td>partitionKey</td><td></td><td>optional</td></tr><tr><td>opaqueKey</td><td></td><td>optional</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nativekafkaclientbuffertopic-identifier-payload-_-partition-version-partitionkey-⇒-promiseltvoidgt"></a>nativeKafkaClient.buffer(topic, identifier, payload, _, partition, version, partitionKey) ⇒ <code>Promise.&amp;lt;void&amp;gt;</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#nativekafkaclientbuffertopic-identifier-payload-_-partition-version-partitionkey-⇒-promiseltvoidgt" title="Direct link to heading">#</a></h3><p>buffers a keyed message to be send
a keyed message needs an identifier, if none is provided
an uuid.v4() will be generated</p><p><strong>Kind</strong>: instance method of <a href="#nativekafkaclient"><code>NativeKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>topic</td><td></td><td></td></tr><tr><td>identifier</td><td></td><td></td></tr><tr><td>payload</td><td></td><td></td></tr><tr><td>_</td><td></td><td>optional</td></tr><tr><td>partition</td><td></td><td>optional</td></tr><tr><td>version</td><td></td><td>optional</td></tr><tr><td>partitionKey</td><td></td><td>optional</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="nativekafkaclientbufferformattopic-identifier-payload-version-_-partitionkey-partition-⇒-promiseltvoidgt"></a>nativeKafkaClient.bufferFormat(topic, identifier, payload, version, _, partitionKey, partition) ⇒ <code>Promise.&amp;lt;void&amp;gt;</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#nativekafkaclientbufferformattopic-identifier-payload-version-_-partitionkey-partition-⇒-promiseltvoidgt" title="Direct link to heading">#</a></h3><p>buffers a keyed message in (a base json format) to be send
a keyed message needs an identifier, if none is provided
an uuid.4() will be generated</p><p><strong>Kind</strong>: instance method of <a href="#nativekafkaclient"><code>NativeKafkaClient</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>topic</td><td></td><td></td></tr><tr><td>identifier</td><td></td><td></td></tr><tr><td>payload</td><td></td><td></td></tr><tr><td>version</td><td><code>1</code></td><td>optional</td></tr><tr><td>_</td><td></td><td>optional</td></tr><tr><td>partitionKey</td><td></td><td>optional</td></tr><tr><td>partition</td><td></td><td>optional</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstream"></a>KStream<a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstream" title="Direct link to heading">#</a></h2><p>change-log representation of a stream</p><p><strong>Kind</strong>: global class  </p><ul><li><a href="#kstream">KStream</a><ul><li><a href="#new-kstreamtopicname-storage-kafka-isclone">new KStream(topicName, storage, kafka, isClone)</a></li><li><a href="#kstreamstartkafkareadycallback-kafkaerrorcallback-withbackpressure-outputkafkaconfig">.start(kafkaReadyCallback, kafkaErrorCallback, withBackPressure, outputKafkaConfig)</a></li><li><a href="#kstream+innerjoin">.innerJoin(stream, key, windowed, combine)</a> ⇒ <a href="#kstreaminnerjoinstream-key-windowed-combine-%E2%87%92-kstream"><code>KStream</code></a></li><li><a href="#kstreamouterjoinstream">.outerJoin(stream)</a></li><li><a href="#kstreamleftjoinstream">.leftJoin(stream)</a></li><li><a href="#kstreammergestream-%E2%87%92-kstream">.merge(stream)</a> ⇒ <a href="#kstream"><code>KStream</code></a></li><li><a href="#kstreamfrommost-%E2%87%92-kstream">.fromMost()</a> ⇒ <a href="#kstream"><code>KStream</code></a></li><li><a href="#kstreamclonecloneevents-clonedeep-%E2%87%92-kstream">.clone(cloneEvents, cloneDeep)</a> ⇒ <a href="#kstream"><code>KStream</code></a></li><li><a href="#kstreambranchpreds-%E2%87%92-arrayltkstreamgt">.branch(preds)</a> ⇒ <a href="#kstream"><code>Array.&amp;lt;KStream&amp;gt;</code></a></li><li><a href="#kstreamwindowfrom-to-etl-encapsulated-collect-%E2%87%92-object">.window(from, to, etl, encapsulated, collect)</a> ⇒ <code>Object</code></li><li><a href="#kstreamclose-%E2%87%92-promiseltbooleangt">.close()</a> ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="new-kstreamtopicname-storage-kafka-isclone"></a>new KStream(topicName, storage, kafka, isClone)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#new-kstreamtopicname-storage-kafka-isclone" title="Direct link to heading">#</a></h3><p>creates a changelog representation of a stream
join operations of kstream instances are synchronous
and return new instances immediately</p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>topicName</td><td><code>string</code></td><td></td></tr><tr><td>storage</td><td><code>KStorage</code></td><td></td></tr><tr><td>kafka</td><td><code>KafkaClient</code></td><td></td></tr><tr><td>isClone</td><td><code>boolean</code></td><td><code>false</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreamstartkafkareadycallback-kafkaerrorcallback-withbackpressure-outputkafkaconfig"></a>kStream.start(kafkaReadyCallback, kafkaErrorCallback, withBackPressure, outputKafkaConfig)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreamstartkafkareadycallback-kafkaerrorcallback-withbackpressure-outputkafkaconfig" title="Direct link to heading">#</a></h3><p>start kafka consumption
prepare production of messages if necessary
when called with zero or just a single callback argument
this function will return a promise and use the callback for errors</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>kafkaReadyCallback</td><td><code>function</code> | <code>Object</code></td><td></td><td>can also be an object (config)</td></tr><tr><td>kafkaErrorCallback</td><td><code>function</code></td><td></td><td></td></tr><tr><td>withBackPressure</td><td><code>boolean</code></td><td><code>false</code></td><td></td></tr><tr><td>outputKafkaConfig</td><td><code>Object</code></td><td></td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreaminnerjoinstream-key-windowed-combine-⇒-kstream"></a>kStream.innerJoin(stream, key, windowed, combine) ⇒ <a href="#kstream"><code>KStream</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreaminnerjoinstream-key-windowed-combine-⇒-kstream" title="Direct link to heading">#</a></h3><p>Emits an output when both input sources have records with the same key.
s1$:{object} + s2$:{object} -&gt; j$:{left: s1$object, right: s2$object}</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>stream</td><td><a href="#streamdsl"><code>StreamDSL</code></a></td><td></td></tr><tr><td>key</td><td><code>string</code></td><td><code>&amp;quot;key&amp;quot;</code></td></tr><tr><td>windowed</td><td><code>boolean</code></td><td><code>false</code></td></tr><tr><td>combine</td><td><code>function</code></td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreamouterjoinstream"></a>kStream.outerJoin(stream)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreamouterjoinstream" title="Direct link to heading">#</a></h3><p>Emits an output for each record in either input source.
If only one source contains a key, the other is null</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>stream</td><td><a href="#streamdsl"><code>StreamDSL</code></a></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreamleftjoinstream"></a>kStream.leftJoin(stream)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreamleftjoinstream" title="Direct link to heading">#</a></h3><p>Emits an output for each record in the left or primary input source.
If the other source does not have a value for a given key, it is set to null</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>stream</td><td><a href="#streamdsl"><code>StreamDSL</code></a></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreammergestream-⇒-kstream"></a>kStream.merge(stream) ⇒ <a href="#kstream"><code>KStream</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreammergestream-⇒-kstream" title="Direct link to heading">#</a></h3><p>Emits an output for each record in any of the streams.
Acts as simple merge of both streams.
can be used with KStream or KTable instances
returns a NEW KStream instance</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>stream</td><td><a href="#streamdsl"><code>StreamDSL</code></a></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreamfrommost-⇒-kstream"></a>kStream.fromMost() ⇒ <a href="#kstream"><code>KStream</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreamfrommost-⇒-kstream" title="Direct link to heading">#</a></h3><p>creates a new KStream instance from a given most.js
stream; the consume topic will be empty and therefore
no consumer will be build</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>most.js</td><td><code>Object</code></td><td>stream</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreamclonecloneevents-clonedeep-⇒-kstream"></a>kStream.clone(cloneEvents, cloneDeep) ⇒ <a href="#kstream"><code>KStream</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreamclonecloneevents-clonedeep-⇒-kstream" title="Direct link to heading">#</a></h3><p>as only joins and window operations return new stream instances
you might need a clone sometimes, which can be accomplished
using this function</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>cloneEvents</td><td><code>boolean</code></td><td><code>false</code></td><td>if events in the stream should be cloned</td></tr><tr><td>cloneDeep</td><td><code>boolean</code></td><td><code>false</code></td><td>if events in the stream should be cloned deeply</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreambranchpreds-⇒-arrayltkstreamgt"></a>kStream.branch(preds) ⇒ <a href="#kstream"><code>Array.&amp;lt;KStream&amp;gt;</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreambranchpreds-⇒-arrayltkstreamgt" title="Direct link to heading">#</a></h3><p>Splits a stream into multiple branches based on cloning
and filtering it depending on the passed predicates.
[ (message) =&gt; message.key.startsWith(&quot;A&quot;),
(message) =&gt; message.key.startsWith(&quot;B&quot;),</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="message--true-"></a>(message) =&gt; true ]<a aria-hidden="true" tabindex="-1" class="hash-link" href="#message--true-" title="Direct link to heading">#</a></h2><p>[ streamA, streamB, streamTrue ]</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>preds</td><td><code>Array.&amp;lt;function()&amp;gt;</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreamwindowfrom-to-etl-encapsulated-collect-⇒-object"></a>kStream.window(from, to, etl, encapsulated, collect) ⇒ <code>Object</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreamwindowfrom-to-etl-encapsulated-collect-⇒-object" title="Direct link to heading">#</a></h3><p>builds a window&#x27;ed stream across all events of the current kstream
when the first event with an exceeding &quot;to&quot; is received (or the abort()
callback is called) the window closes and emits its &quot;collected&quot; values to the
returned kstream
from and to must be unix epoch timestamps in milliseconds (Date.now())
etl can be a function that should return the timestamp (event time) of
from within the message e.g. m -&gt; m.payload.createdAt
if etl is not given, a timestamp of receiving will be used (processing time)
for each event
encapsulated refers to the result messages (defaults to true, they will be
encapsulated in an object: {time, value}</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>from</td><td><code>number</code></td><td></td><td></td></tr><tr><td>to</td><td><code>number</code></td><td></td><td></td></tr><tr><td>etl</td><td><code>function</code></td><td></td><td></td></tr><tr><td>encapsulated</td><td><code>boolean</code></td><td><code>true</code></td><td>if event should stay encapsulated {time, value}</td></tr><tr><td>collect</td><td><code>boolean</code></td><td><code>true</code></td><td>if events should be collected first before publishing to result stream</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kstreamclose-⇒-promiseltbooleangt"></a>kStream.close() ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#kstreamclose-⇒-promiseltbooleangt" title="Direct link to heading">#</a></h3><p>closes the internal stream
and all kafka open connections
as well as KStorage connections</p><p><strong>Kind</strong>: instance method of <a href="#kstream"><code>KStream</code></a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktable"></a>KTable<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktable" title="Direct link to heading">#</a></h2><p>table representation of a stream</p><p><strong>Kind</strong>: global class  </p><ul><li><a href="#ktable">KTable</a><ul><li><a href="#new_ktable_new">new KTable(topicName, keyMapETL, storage, kafka, isClone)</a></li><li><a href="#ktable+start">.start(kafkaReadyCallback, kafkaErrorCallback, withBackPressure, outputKafkaConfig)</a></li><li><a href="#ktable+innerjoinstream-key">.innerJoin(stream, key)</a></li><li><a href="#ktable+outerjoinstream">.outerJoin(stream)</a></li><li><a href="#ktableleftjoinstream">.leftJoin(stream)</a></li><li><a href="#ktable+writetotablestream">.writeToTableStream(message)</a></li><li><a href="#ktable+consumeuntilms">.consumeUntilMs(ms, finishedCallback)</a> ⇒ <a href="#ktable"><code>KTable</code></a></li><li><a href="#ktable+consumeuntilcount">.consumeUntilCount(count, finishedCallback)</a> ⇒ <a href="#ktable"><code>KTable</code></a></li><li><a href="#ktable+consumeuntillatestoffset">.consumeUntilLatestOffset(finishedCallback)</a></li><li><a href="#ktable+gettable">.getTable()</a> ⇒ <code>Promise.&amp;lt;object&amp;gt;</code></li><li><a href="#ktable+replay">.replay()</a></li><li><a href="#ktable+merge">.merge(stream)</a> ⇒ <a href="#ktable"><code>Promise.&amp;lt;KTable&amp;gt;</code></a></li><li><a href="#ktable+clone">.clone()</a> ⇒ <a href="#ktable"><code>Promise.&amp;lt;KTable&amp;gt;</code></a></li><li><a href="#ktable+close">.close()</a> ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="new-ktabletopicname-keymapetl-storage-kafka-isclone"></a>new KTable(topicName, keyMapETL, storage, kafka, isClone)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#new-ktabletopicname-keymapetl-storage-kafka-isclone" title="Direct link to heading">#</a></h3><p>creates a table representation of a stream
join operations of ktable instances are asynchronous
and return promises
keyMapETL = v -&gt; {key, value} (sync)</p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>topicName</td><td><code>string</code></td><td></td></tr><tr><td>keyMapETL</td><td><code>function</code></td><td></td></tr><tr><td>storage</td><td><code>KStorage</code></td><td></td></tr><tr><td>kafka</td><td><code>KafkaClient</code></td><td></td></tr><tr><td>isClone</td><td><code>boolean</code></td><td><code>false</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktablestartkafkareadycallback-kafkaerrorcallback-withbackpressure-outputkafkaconfig"></a>kTable.start(kafkaReadyCallback, kafkaErrorCallback, withBackPressure, outputKafkaConfig)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktablestartkafkareadycallback-kafkaerrorcallback-withbackpressure-outputkafkaconfig" title="Direct link to heading">#</a></h3><p>start kafka consumption
prepare production of messages if necessary
when called with zero or just a single callback argument
this function will return a promise and use the callback for errors</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>kafkaReadyCallback</td><td><code>function</code> | <code>Object</code></td><td></td><td>can also be an object (config)</td></tr><tr><td>kafkaErrorCallback</td><td><code>function</code></td><td></td><td></td></tr><tr><td>withBackPressure</td><td><code>boolean</code></td><td><code>false</code></td><td></td></tr><tr><td>outputKafkaConfig</td><td><code>Object</code></td><td></td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktableinnerjoinstream-key"></a>kTable.innerJoin(stream, key)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktableinnerjoinstream-key" title="Direct link to heading">#</a></h3><p>Emits an output when both input sources have records with the same key.</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>stream</td><td><a href="#streamdsl"><code>StreamDSL</code></a></td><td></td></tr><tr><td>key</td><td><code>string</code></td><td><code>&amp;quot;key&amp;quot;</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktableouterjoinstream"></a>kTable.outerJoin(stream)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktableouterjoinstream" title="Direct link to heading">#</a></h3><p>Emits an output for each record in either input source.
If only one source contains a key, the other is null</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>stream</td><td><a href="#streamdsl"><code>StreamDSL</code></a></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktableleftjoinstream"></a>kTable.leftJoin(stream)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktableleftjoinstream" title="Direct link to heading">#</a></h3><p>Emits an output for each record in the left or primary input source.
If the other source does not have a value for a given key, it is set to null</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>stream</td><td><a href="#streamdsl"><code>StreamDSL</code></a></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktablewritetotablestreammessage"></a>kTable.writeToTableStream(message)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktablewritetotablestreammessage" title="Direct link to heading">#</a></h3><p>write message to the internal stream</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>message</td><td><code>any</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktableconsumeuntilmsms-finishedcallback-⇒-ktable"></a>kTable.consumeUntilMs(ms, finishedCallback) ⇒ <a href="#ktable"><code>KTable</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktableconsumeuntilmsms-finishedcallback-⇒-ktable" title="Direct link to heading">#</a></h3><p>consume messages until ms passed</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>ms</td><td><code>number</code></td><td><code>1000</code></td></tr><tr><td>finishedCallback</td><td><code>function</code></td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktableconsumeuntilcountcount-finishedcallback-⇒-ktable"></a>kTable.consumeUntilCount(count, finishedCallback) ⇒ <a href="#ktable"><code>KTable</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktableconsumeuntilcountcount-finishedcallback-⇒-ktable" title="Direct link to heading">#</a></h3><p>consume messages until a certain count is reached</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>count</td><td><code>number</code></td><td><code>1000</code></td></tr><tr><td>finishedCallback</td><td><code>function</code></td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktableconsumeuntillatestoffsetfinishedcallback"></a>kTable.consumeUntilLatestOffset(finishedCallback)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktableconsumeuntillatestoffsetfinishedcallback" title="Direct link to heading">#</a></h3><p>consume messages until latest offset of topic</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>finishedCallback</td><td><code>function</code></td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktablegettable-⇒-promiseltobjectgt"></a>kTable.getTable() ⇒ <code>Promise.&amp;lt;object&amp;gt;</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktablegettable-⇒-promiseltobjectgt" title="Direct link to heading">#</a></h3><p>returns the state of the internal KStorage</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktablereplay"></a>kTable.replay()<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktablereplay" title="Direct link to heading">#</a></h3><p>rewrites content of internal KStorage
to the stream, every observer will receive
the content as KV {key, value} object</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktablemergestream-⇒-promiseltktablegt"></a>kTable.merge(stream) ⇒ <a href="#ktable"><code>Promise.&amp;lt;KTable&amp;gt;</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktablemergestream-⇒-promiseltktablegt" title="Direct link to heading">#</a></h3><p>Emits an output for each record in any of the streams.
Acts as simple merge of both streams.
can be used with KStream or KTable instances
returns a Promise with a NEW KTable instance</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>stream</td><td><a href="#streamdsl"><code>StreamDSL</code></a></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktableclone-⇒-promiseltktablegt"></a>kTable.clone() ⇒ <a href="#ktable"><code>Promise.&amp;lt;KTable&amp;gt;</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktableclone-⇒-promiseltktablegt" title="Direct link to heading">#</a></h3><p>as only joins and window operations return new stream instances
you might need a clone sometimes, which can be accomplished
using this function</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ktableclose-⇒-promiseltbooleangt"></a>kTable.close() ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#ktableclose-⇒-promiseltbooleangt" title="Direct link to heading">#</a></h3><p>closes the internal stream
and all kafka open connections
as well as KStorage connections</p><p><strong>Kind</strong>: instance method of <a href="#ktable"><code>KTable</code></a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsl"></a>StreamDSL<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsl" title="Direct link to heading">#</a></h2><p>Stream base class</p><p><strong>Kind</strong>: global class  </p><ul><li><a href="#summary">Summary</a></li><li><a href="#keycount">KeyCount</a></li><li><a href="#laststate">LastState</a></li><li><a href="#max">Max</a></li><li><a href="#min">Min</a></li><li><a href="#sum">Sum</a></li><li><a href="#window">Window</a></li><li><a href="#jskafkaclient">JSKafkaClient</a><ul><li><a href="#new-jskafkaclienttopic-config">new JSKafkaClient(topic, config)</a></li><li><a href="#jskafkaclientsetproducehandlerhandler">jsKafkaClient.setProduceHandler(handler)</a></li><li><a href="#jskafkaclientgetproducehandler--null--eventemitter">jsKafkaClient.getProduceHandler() ⇒ <code>null</code> | <code>EventEmitter</code></a></li><li><a href="#jskafkaclientoverwritetopicstopics">jsKafkaClient.overwriteTopics(topics)</a></li><li><a href="#jskafkaclientstartreadycallback-kafkaerrorcallback-withproducer-withbackpressure">jsKafkaClient.start(readyCallback, kafkaErrorCallback, withProducer, withBackPressure)</a></li><li><a href="#jskafkaclientsetupproducerproducetopic-partitions-readycallback-kafkaerrorcallback-outputkafkaconfig">jsKafkaClient.setupProducer(produceTopic, partitions, readyCallback, kafkaErrorCallback, outputKafkaConfig)</a></li><li><a href="#jskafkaclientsendtopic-message--">jsKafkaClient.send(topic, message) ⇒ <code>*</code></a></li><li><a href="#jskafkaclientbuffertopic-identifier-payload-compressiontype--">jsKafkaClient.buffer(topic, identifier, payload, compressionType) ⇒ <code>*</code></a></li><li><a href="#jskafkaclientbufferformattopic-identifier-payload-version-compressiontype--">jsKafkaClient.bufferFormat(topic, identifier, payload, version, compressionType) ⇒ <code>*</code></a></li></ul></li><li><a href="#nativekafkaclient">NativeKafkaClient</a><ul><li><a href="#new-nativekafkaclienttopic-config-batchoptions">new NativeKafkaClient(topic, config, batchOptions)</a></li><li><a href="#nativekafkaclientsetproducehandlerhandler">nativeKafkaClient.setProduceHandler(handler)</a></li><li><a href="#nativekafkaclientgetproducehandler--null--eventemitter">nativeKafkaClient.getProduceHandler() ⇒ <code>null</code> | <code>EventEmitter</code></a></li><li><a href="#nativekafkaclientoverwritetopicstopics">nativeKafkaClient.overwriteTopics(topics)</a></li><li><a href="#nativekafkaclientstartreadycallback-kafkaerrorcallback-withproducer-withbackpressure">nativeKafkaClient.start(readyCallback, kafkaErrorCallback, withProducer, withBackPressure)</a></li><li><a href="#nativekafkaclientsetupproducerproducetopic-partitions-readycallback-kafkaerrorcallback-outputkafkaconfig">nativeKafkaClient.setupProducer(produceTopic, partitions, readyCallback, kafkaErrorCallback, outputKafkaConfig)</a></li><li><a href="#nativekafkaclientsendtopicname-message-partition-key-partitionkey-opaquekey--promiseltvoidgt">nativeKafkaClient.send(topicName, message, partition, key, partitionKey, opaqueKey) ⇒ <code>Promise.&amp;lt;void&amp;gt;</code></a></li><li><a href="#nativekafkaclientbuffertopic-identifier-payload-_-partition-version-partitionkey--promiseltvoidgt">nativeKafkaClient.buffer(topic, identifier, payload, _, partition, version, partitionKey) ⇒ <code>Promise.&amp;lt;void&amp;gt;</code></a></li><li><a href="#nativekafkaclientbufferformattopic-identifier-payload-version-_-partitionkey-partition--promiseltvoidgt">nativeKafkaClient.bufferFormat(topic, identifier, payload, version, _, partitionKey, partition) ⇒ <code>Promise.&amp;lt;void&amp;gt;</code></a></li></ul></li><li><a href="#kstream">KStream</a><ul><li><a href="#new-kstreamtopicname-storage-kafka-isclone">new KStream(topicName, storage, kafka, isClone)</a></li><li><a href="#kstreamstartkafkareadycallback-kafkaerrorcallback-withbackpressure-outputkafkaconfig">kStream.start(kafkaReadyCallback, kafkaErrorCallback, withBackPressure, outputKafkaConfig)</a></li><li><a href="#kstreaminnerjoinstream-key-windowed-combine--kstream">kStream.innerJoin(stream, key, windowed, combine) ⇒ <code>KStream</code></a></li><li><a href="#kstreamouterjoinstream">kStream.outerJoin(stream)</a></li><li><a href="#kstreamleftjoinstream">kStream.leftJoin(stream)</a></li><li><a href="#kstreammergestream--kstream">kStream.merge(stream) ⇒ <code>KStream</code></a></li><li><a href="#kstreamfrommost--kstream">kStream.fromMost() ⇒ <code>KStream</code></a></li><li><a href="#kstreamclonecloneevents-clonedeep--kstream">kStream.clone(cloneEvents, cloneDeep) ⇒ <code>KStream</code></a></li><li><a href="#kstreambranchpreds--arrayltkstreamgt">kStream.branch(preds) ⇒ <code>Array.&amp;lt;KStream&amp;gt;</code></a></li></ul></li><li>[(message) =&gt; true ]](#message--true-)<ul><li><a href="#kstreamwindowfrom-to-etl-encapsulated-collect--object">kStream.window(from, to, etl, encapsulated, collect) ⇒ <code>Object</code></a></li><li><a href="#kstreamclose--promiseltbooleangt">kStream.close() ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code></a></li></ul></li><li><a href="#ktable">KTable</a><ul><li><a href="#new-ktabletopicname-keymapetl-storage-kafka-isclone">new KTable(topicName, keyMapETL, storage, kafka, isClone)</a></li><li><a href="#ktablestartkafkareadycallback-kafkaerrorcallback-withbackpressure-outputkafkaconfig">kTable.start(kafkaReadyCallback, kafkaErrorCallback, withBackPressure, outputKafkaConfig)</a></li><li><a href="#ktableinnerjoinstream-key">kTable.innerJoin(stream, key)</a></li><li><a href="#ktableouterjoinstream">kTable.outerJoin(stream)</a></li><li><a href="#ktableleftjoinstream">kTable.leftJoin(stream)</a></li><li><a href="#ktablewritetotablestreammessage">kTable.writeToTableStream(message)</a></li><li><a href="#ktableconsumeuntilmsms-finishedcallback--ktable">kTable.consumeUntilMs(ms, finishedCallback) ⇒ <code>KTable</code></a></li><li><a href="#ktableconsumeuntilcountcount-finishedcallback--ktable">kTable.consumeUntilCount(count, finishedCallback) ⇒ <code>KTable</code></a></li><li><a href="#ktableconsumeuntillatestoffsetfinishedcallback">kTable.consumeUntilLatestOffset(finishedCallback)</a></li><li><a href="#ktablegettable--promiseltobjectgt">kTable.getTable() ⇒ <code>Promise.&amp;lt;object&amp;gt;</code></a></li><li><a href="#ktablereplay">kTable.replay()</a></li><li><a href="#ktablemergestream--promiseltktablegt">kTable.merge(stream) ⇒ <code>Promise.&amp;lt;KTable&amp;gt;</code></a></li><li><a href="#ktableclone--promiseltktablegt">kTable.clone() ⇒ <code>Promise.&amp;lt;KTable&amp;gt;</code></a></li><li><a href="#ktableclose--promiseltbooleangt">kTable.close() ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code></a></li></ul></li><li><a href="#streamdsl">StreamDSL</a><ul><li><a href="#new-streamdsltopicname-storage-kafka-isclone">new StreamDSL(topicName, storage, kafka, isClone)</a></li><li><a href="#streamdslstart">streamDSL.start()</a></li><li><a href="#streamdslgetstats--object">streamDSL.getStats() ⇒ <code>object</code></a></li><li><a href="#streamdslgetstorage--kstorage">streamDSL.getStorage() ⇒ <code>KStorage</code></a></li><li><a href="#streamdslwritetostreammessage">streamDSL.writeToStream(message)</a></li><li><a href="#streamdslgetmost--object">streamDSL.getMost() ⇒ <code>Object</code></a></li><li><a href="#streamdslgetnewmostfromarray--streamltanygt">streamDSL.getNewMostFrom(array) ⇒ <code>Stream.&amp;lt;any&amp;gt;</code></a></li><li><a href="#streamdslreplaceinternalobservablenewstream">streamDSL.replaceInternalObservable(newStream$)</a></li><li><a href="#streamdslsetproducehandlerhandler">streamDSL.setProduceHandler(handler)</a></li><li><a href="#streamdslcreateandsetproducehandler--moduleeventsinternal">streamDSL.createAndSetProduceHandler() ⇒ <code>module:events.internal</code></a></li><li><a href="#streamdslsetkafkastreamsreferencereference">streamDSL.setKafkaStreamsReference(reference)</a></li><li><a href="#streamdslfromtopicname--streamdsl">streamDSL.from(topicName) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslawaitpromisesetl--streamdsl">streamDSL.awaitPromises(etl) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapetl--streamdsl">streamDSL.map(etl) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslasyncmapetl--streamdsl">streamDSL.asyncMap(etl) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslconcatmapetl--streamdsl">streamDSL.concatMap(etl) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslforeacheff--">streamDSL.forEach(eff) ⇒ <code>\*</code></a></li><li><a href="#streamdslchainforeacheff-callback--streamdsl">streamDSL.chainForEach(eff, callback) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdsltapeff">streamDSL.tap(eff)</a></li><li><a href="#streamdslfilterpred--streamdsl">streamDSL.filter(pred) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslskiprepeats--streamdsl">streamDSL.skipRepeats() ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslskiprepeatswithequals--streamdsl">streamDSL.skipRepeatsWith(equals) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslskipcount--streamdsl">streamDSL.skip(count) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdsltakecount--streamdsl">streamDSL.take(count) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapstringtoarraydelimiter--streamdsl">streamDSL.mapStringToArray(delimiter) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmaparraytokvkeyindex-valueindex--streamdsl">streamDSL.mapArrayToKV(keyIndex, valueIndex) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapstringtokvdelimiter-keyindex-valueindex--streamdsl">streamDSL.mapStringToKV(delimiter, keyIndex, valueIndex) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapjsonparse--streamdsl">streamDSL.mapJSONParse() ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapstringify--streamdsl">streamDSL.mapStringify() ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapbufferkeytostring--streamdsl">streamDSL.mapBufferKeyToString() ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapbuffervaluetostring--streamdsl">streamDSL.mapBufferValueToString() ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapstringvaluetojsonobject--streamdsl">streamDSL.mapStringValueToJSONObject() ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapjsonconvenience--streamdsl">streamDSL.mapJSONConvenience() ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslwrapaskafkavaluetopic--streamdsl">streamDSL.wrapAsKafkaValue(topic) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapwrapkafkavalue--streamdsl">streamDSL.mapWrapKafkaValue() ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslatthroughputcount-callback--streamdsl">streamDSL.atThroughput(count, callback) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmaptoformattype-getid--streamdsl">streamDSL.mapToFormat(type, getId) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmapfromformat--streamdsl">streamDSL.mapFromFormat() ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdsltimestampetl--streamdsl">streamDSL.timestamp(etl) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslconstantsubstitute--streamdsl">streamDSL.constant(substitute) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslscaneff-initial--streamdsl">streamDSL.scan(eff, initial) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslslicestart-end--streamdsl">streamDSL.slice(start, end) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdsltakewhilepred--streamdsl">streamDSL.takeWhile(pred) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslskipwhilepred--streamdsl">streamDSL.skipWhile(pred) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdsluntilsignal--streamdsl">streamDSL.until(signal$) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslsincesignal--streamdsl">streamDSL.since(signal$) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslcontinuewithf">streamDSL.continueWith(f)</a></li><li><a href="#streamdslreduceeff-initial--">streamDSL.reduce(eff, initial) ⇒ <code>\*</code></a></li><li><a href="#streamdslchainreduceeff-initial-callback--streamdsl">streamDSL.chainReduce(eff, initial, callback) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdsldrain--">streamDSL.drain() ⇒ <code>\*</code></a></li><li><a href="#streamdslthrottlethrottleperiod--streamdsl">streamDSL.throttle(throttlePeriod) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdsldelaydelaytime--streamdsl">streamDSL.delay(delayTime) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdsldebouncedebouncetime--streamdsl">streamDSL.debounce(debounceTime) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslcountbykeykey-countfieldname--streamdsl">streamDSL.countByKey(key, countFieldName) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslsumbykeykey-fieldname-sumfield--streamdsl">streamDSL.sumByKey(key, fieldName, sumField) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslminfieldname-minfield--streamdsl">streamDSL.min(fieldName, minField) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdslmaxfieldname-maxfield--streamdsl">streamDSL.max(fieldName, maxField) ⇒ <code>StreamDSL</code></a></li><li><a href="#streamdsl_mergeotherstream">streamDSL._merge(otherStream$)</a></li><li><a href="#streamdsl_zipotherstream-combine">streamDSL._zip(otherStream$, combine)</a></li><li><a href="#streamdsltotopic-outputpartitionscount-producetype-version-compressiontype-producererrorcallback-outputkafkaconfig--promiseltbooleangt">streamDSL.to(topic, outputPartitionsCount, produceType, version, compressionType, producerErrorCallback, outputKafkaConfig) ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code></a></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="new-streamdsltopicname-storage-kafka-isclone"></a>new StreamDSL(topicName, storage, kafka, isClone)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#new-streamdsltopicname-storage-kafka-isclone" title="Direct link to heading">#</a></h3><p>Stream base class that wraps around a private most.js stream$
and interacts with storages/actions and a kafka-client instance.</p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>topicName</td><td><code>string</code> | <code>Array.&amp;lt;string&amp;gt;</code></td><td></td><td>can also be topics</td></tr><tr><td>storage</td><td><code>KStorage</code></td><td></td><td></td></tr><tr><td>kafka</td><td><code>KafkaClient</code></td><td></td><td></td></tr><tr><td>isClone</td><td><code>boolean</code></td><td><code>false</code></td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslstart"></a>streamDSL.start()<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslstart" title="Direct link to heading">#</a></h3><p>dummy, should be overwritten</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslgetstats-⇒-object"></a>streamDSL.getStats() ⇒ <code>object</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslgetstats-⇒-object" title="Direct link to heading">#</a></h3><p>returns a stats object with information
about the internal kafka clients</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslgetstorage-⇒-kstorage"></a>streamDSL.getStorage() ⇒ <code>KStorage</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslgetstorage-⇒-kstorage" title="Direct link to heading">#</a></h3><p>returns the internal KStorage instance</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslwritetostreammessage"></a>streamDSL.writeToStream(message)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslwritetostreammessage" title="Direct link to heading">#</a></h3><p>can be used to manually write message/events
to the internal stream$</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>message</td><td><code>Object</code> | <code>Array.&amp;lt;Object&amp;gt;</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslgetmost-⇒-object"></a>streamDSL.getMost() ⇒ <code>Object</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslgetmost-⇒-object" title="Direct link to heading">#</a></h3><p>returns the internal most.js stream</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a><br>
<strong>Returns</strong>: <code>Object</code> - most.js stream</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslgetnewmostfromarray-⇒-streamltanygt"></a>streamDSL.getNewMostFrom(array) ⇒ <code>Stream.&amp;lt;any&amp;gt;</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslgetnewmostfromarray-⇒-streamltanygt" title="Direct link to heading">#</a></h3><p>returns a new most stream from the
given array</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>array</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslreplaceinternalobservablenewstream"></a>streamDSL.replaceInternalObservable(newStream$)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslreplaceinternalobservablenewstream" title="Direct link to heading">#</a></h3><p>used to clone or during merges
resets the internal event emitter to the new stream
and replaces the internal stream with the merged new stream</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>newStream$</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslsetproducehandlerhandler"></a>streamDSL.setProduceHandler(handler)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslsetproducehandlerhandler" title="Direct link to heading">#</a></h3><p>sets a handler for produce messages
(emits whenever kafka messages are produced/delivered)
events: produced, delivered</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>handler</td><td><code>module:events.internal</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslcreateandsetproducehandler-⇒-moduleeventsinternal"></a>streamDSL.createAndSetProduceHandler() ⇒ <code>module:events.internal</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslcreateandsetproducehandler-⇒-moduleeventsinternal" title="Direct link to heading">#</a></h3><p>creates (and returns) and sets a produce handler
for this stream instance</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslsetkafkastreamsreferencereference"></a>streamDSL.setKafkaStreamsReference(reference)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslsetkafkastreamsreferencereference" title="Direct link to heading">#</a></h3><p>overwrites the internal kafkaStreams reference</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>reference</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslfromtopicname-⇒-streamdsl"></a>streamDSL.from(topicName) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslfromtopicname-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>add more topic/s to the consumer</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th></tr></thead><tbody><tr><td>topicName</td><td><code>string</code> | <code>Array.&amp;lt;string&amp;gt;</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslawaitpromisesetl-⇒-streamdsl"></a>streamDSL.awaitPromises(etl) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslawaitpromisesetl-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>given a stream of promises, returns stream containing the fulfillment values
etl = Promise -&gt; v</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>etl</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapetl-⇒-streamdsl"></a>streamDSL.map(etl) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapetl-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>simple synchronous map function
etl = v -&gt; v2</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>etl</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslasyncmapetl-⇒-streamdsl"></a>streamDSL.asyncMap(etl) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslasyncmapetl-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>map that expects etl to return a Promise
can be used to apply async maps to stream
etl = v -&gt; Promise</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>etl</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslconcatmapetl-⇒-streamdsl"></a>streamDSL.concatMap(etl) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslconcatmapetl-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>transform each etl in stream into a stream,
and then concatenate it onto the end of the resulting stream.
etl = v -&gt; stream(v2)</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>etl</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslforeacheff-⇒-"></a>streamDSL.forEach(eff) ⇒ <code>\*</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslforeacheff-⇒-" title="Direct link to heading">#</a></h3><p>(do not use for side effects,
except for a closing operation at the end of the stream)
may not be used to chain
eff = v -&gt; void</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a><br>
<strong>Returns</strong>: <code>\*</code> - Promise  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>eff</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslchainforeacheff-callback-⇒-streamdsl"></a>streamDSL.chainForEach(eff, callback) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslchainforeacheff-callback-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>runs forEach on a multicast stream
you probably would not want to use this in production</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>eff</td><td></td></tr><tr><td>callback</td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsltapeff"></a>streamDSL.tap(eff)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsltapeff" title="Direct link to heading">#</a></h3><p>(alternative to forEach if in the middle of a
stream operation chain)
use this for side-effects
errors in eff will break stream</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>eff</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslfilterpred-⇒-streamdsl"></a>streamDSL.filter(pred) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslfilterpred-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>stream contains only events for which predicate
returns true
pred = v -&gt; boolean</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>pred</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslskiprepeats-⇒-streamdsl"></a>streamDSL.skipRepeats() ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslskiprepeats-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>will remove duplicate messages
be aware that this might take a lot of memory</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslskiprepeatswithequals-⇒-streamdsl"></a>streamDSL.skipRepeatsWith(equals) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslskiprepeatswithequals-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>skips repeats per your definition
equals = (a,b) -&gt; boolean</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>equals</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslskipcount-⇒-streamdsl"></a>streamDSL.skip(count) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslskipcount-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>skips the amount of messages</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>count</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsltakecount-⇒-streamdsl"></a>streamDSL.take(count) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsltakecount-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>takes the first messages until count
and omits the rest</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>count</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapstringtoarraydelimiter-⇒-streamdsl"></a>streamDSL.mapStringToArray(delimiter) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapstringtoarraydelimiter-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>easy string to array mapping
you can pass your delimiter
default is space
&quot;bla blup&quot; =&gt; [&quot;bla&quot;, &quot;blup&quot;]</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>delimiter</td><td><code> </code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmaparraytokvkeyindex-valueindex-⇒-streamdsl"></a>streamDSL.mapArrayToKV(keyIndex, valueIndex) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmaparraytokvkeyindex-valueindex-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>easy array to key-value object mapping
you can pass your own indices
default is 0,1
[&quot;bla&quot;, &quot;blup&quot;] =&gt; { key: &quot;bla&quot;, value: &quot;blup&quot; }</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>keyIndex</td><td><code>0</code></td></tr><tr><td>valueIndex</td><td><code>1</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapstringtokvdelimiter-keyindex-valueindex-⇒-streamdsl"></a>streamDSL.mapStringToKV(delimiter, keyIndex, valueIndex) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapstringtokvdelimiter-keyindex-valueindex-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>easy string to key-value object mapping
you can pass your own delimiter and indices
default is &quot; &quot; and 0,1
&quot;bla blup&quot; =&gt; { key: &quot;bla&quot;, value: &quot;blup&quot; }</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>delimiter</td><td><code> </code></td></tr><tr><td>keyIndex</td><td><code>0</code></td></tr><tr><td>valueIndex</td><td><code>1</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapjsonparse-⇒-streamdsl"></a>streamDSL.mapJSONParse() ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapjsonparse-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>maps every stream event through JSON.parse
if its type is an object
(if parsing fails, the error object will be returned)</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapstringify-⇒-streamdsl"></a>streamDSL.mapStringify() ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapstringify-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>maps every stream event through JSON.stringify
if its type is object</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapbufferkeytostring-⇒-streamdsl"></a>streamDSL.mapBufferKeyToString() ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapbufferkeytostring-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>maps an object type event with a Buffer key field
to an object event with a string key field</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapbuffervaluetostring-⇒-streamdsl"></a>streamDSL.mapBufferValueToString() ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapbuffervaluetostring-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>maps an object type event with a Buffer value field
to an object event with a string value field</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapstringvaluetojsonobject-⇒-streamdsl"></a>streamDSL.mapStringValueToJSONObject() ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapstringvaluetojsonobject-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>maps an object type event with a string value field
to an object event with (parsed) object value field</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapjsonconvenience-⇒-streamdsl"></a>streamDSL.mapJSONConvenience() ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapjsonconvenience-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>takes a buffer kafka message
and turns it into a json representation
buffer key -&gt; string
buffer value -&gt; string -&gt; object</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslwrapaskafkavaluetopic-⇒-streamdsl"></a>streamDSL.wrapAsKafkaValue(topic) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslwrapaskafkavaluetopic-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>wraps an event value inside a kafka message object
the event value will be used as value of the kafka message</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Description</th></tr></thead><tbody><tr><td>topic</td><td>optional</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapwrapkafkavalue-⇒-streamdsl"></a>streamDSL.mapWrapKafkaValue() ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapwrapkafkavalue-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>maps every stream event&#x27;s kafka message
right to its payload value</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslatthroughputcount-callback-⇒-streamdsl"></a>streamDSL.atThroughput(count, callback) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslatthroughputcount-callback-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>taps to the stream
counts messages and returns
callback once (when message count is reached)
with the current message at count</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>count</td><td><code>number</code></td><td><code>1</code></td></tr><tr><td>callback</td><td><code>function</code></td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmaptoformattype-getid-⇒-streamdsl"></a>streamDSL.mapToFormat(type, getId) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmaptoformattype-getid-⇒-streamdsl" title="Direct link to heading">#</a></h3><ul><li>default kafka format stringify
{} -&gt; {payload, time, type, id}
getId can be a function to read the id from the message
e.g. getId = message -&gt; message.id</li></ul><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>type</td><td><code>unknown-publish</code></td></tr><tr><td>getId</td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmapfromformat-⇒-streamdsl"></a>streamDSL.mapFromFormat() ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmapfromformat-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>default kafka format parser
{value: &quot;{ payload: {} }&quot; -&gt; {}</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsltimestampetl-⇒-streamdsl"></a>streamDSL.timestamp(etl) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsltimestampetl-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>maps elements into {time, value} objects</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>etl</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslconstantsubstitute-⇒-streamdsl"></a>streamDSL.constant(substitute) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslconstantsubstitute-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>replace every element with the substitute value</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>substitute</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslscaneff-initial-⇒-streamdsl"></a>streamDSL.scan(eff, initial) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslscaneff-initial-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>mapping to incrementally accumulated results,
starting with the provided initial value.</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>eff</td></tr><tr><td>initial</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslslicestart-end-⇒-streamdsl"></a>streamDSL.slice(start, end) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslslicestart-end-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>slicing events from start ot end of index</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>start</td></tr><tr><td>end</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsltakewhilepred-⇒-streamdsl"></a>streamDSL.takeWhile(pred) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsltakewhilepred-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>contain events until predicate
returns false
m -&gt; !!m</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>pred</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslskipwhilepred-⇒-streamdsl"></a>streamDSL.skipWhile(pred) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslskipwhilepred-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>contain events after predicate
returns false</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>pred</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsluntilsignal-⇒-streamdsl"></a>streamDSL.until(signal$) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsluntilsignal-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>contain events until signal$ emits first event
signal$ must be a most stream instance</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>signal$</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslsincesignal-⇒-streamdsl"></a>streamDSL.since(signal$) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslsincesignal-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>contain all events after signal$ emits first event
signal$ must be a most stream instance</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>signal$</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslcontinuewithf"></a>streamDSL.continueWith(f)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslcontinuewithf" title="Direct link to heading">#</a></h3><p>Replace the end signal with a new stream returned by f.
Note that f must return a (most.js) stream.</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Description</th></tr></thead><tbody><tr><td>f</td><td>function (must return a most stream)</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslreduceeff-initial-⇒-"></a>streamDSL.reduce(eff, initial) ⇒ <code>\*</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslreduceeff-initial-⇒-" title="Direct link to heading">#</a></h3><p>reduce a stream to a single result
will return a promise</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a><br>
<strong>Returns</strong>: <code>\*</code> - Promise  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>eff</td></tr><tr><td>initial</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslchainreduceeff-initial-callback-⇒-streamdsl"></a>streamDSL.chainReduce(eff, initial, callback) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslchainreduceeff-initial-callback-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>runs reduce on a multicast stream
you probably would not want to use this in production</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>eff</td></tr><tr><td>initial</td></tr><tr><td>callback</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsldrain-⇒-"></a>streamDSL.drain() ⇒ <code>\*</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsldrain-⇒-" title="Direct link to heading">#</a></h3><p>drains the stream, equally to forEach
without iterator, returns a promise</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a><br>
<strong>Returns</strong>: <code>\*</code> - Promise</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslthrottlethrottleperiod-⇒-streamdsl"></a>streamDSL.throttle(throttlePeriod) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslthrottlethrottleperiod-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>limits rate events at most one per throttlePeriod
throttlePeriod = index count omit</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>throttlePeriod</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsldelaydelaytime-⇒-streamdsl"></a>streamDSL.delay(delayTime) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsldelaydelaytime-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>delays every event in stream by given time</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>delayTime</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsldebouncedebouncetime-⇒-streamdsl"></a>streamDSL.debounce(debounceTime) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsldebouncedebouncetime-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>wait for a burst of events and emit
only the last event</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>debounceTime</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslcountbykeykey-countfieldname-⇒-streamdsl"></a>streamDSL.countByKey(key, countFieldName) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslcountbykeykey-countfieldname-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>maps into counts per key
requires events to have a present key/value field</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>key</td><td><code>key</code></td></tr><tr><td>countFieldName</td><td><code>count</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslsumbykeykey-fieldname-sumfield-⇒-streamdsl"></a>streamDSL.sumByKey(key, fieldName, sumField) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslsumbykeykey-fieldname-sumfield-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>maps into sums per key
requires events to have a present key/value field</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>key</td><td><code>key</code></td></tr><tr><td>fieldName</td><td><code>value</code></td></tr><tr><td>sumField</td><td><code>false</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslminfieldname-minfield-⇒-streamdsl"></a>streamDSL.min(fieldName, minField) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslminfieldname-minfield-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>collects the smallest value
of the given field, will not alter
the events in the stream
use .getStorage().getMin() to get the
latest value which is stored</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>fieldName</td><td><code>value</code></td></tr><tr><td>minField</td><td><code>min</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdslmaxfieldname-maxfield-⇒-streamdsl"></a>streamDSL.max(fieldName, maxField) ⇒ <a href="#streamdsl"><code>StreamDSL</code></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdslmaxfieldname-maxfield-⇒-streamdsl" title="Direct link to heading">#</a></h3><p>collects the greatest value
of the given field, will not alter
the events in the stream
use .getStorage().getMax() to get the
latest value which is stored</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Default</th></tr></thead><tbody><tr><td>fieldName</td><td><code>value</code></td></tr><tr><td>maxField</td><td><code>max</code></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsl_mergeotherstream"></a>streamDSL._merge(otherStream$)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsl_mergeotherstream" title="Direct link to heading">#</a></h3><p>merge this stream with another, resulting a
stream with all elements from both streams</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>otherStream$</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsl_zipotherstream-combine"></a>streamDSL._zip(otherStream$, combine)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsl_zipotherstream-combine" title="Direct link to heading">#</a></h3><p>merge this stream with another stream
by combining (zipping) every event from each stream
to a single new event on the new stream
combine = (e1, e2) -&gt; e1 + e2</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th></tr></thead><tbody><tr><td>otherStream$</td></tr><tr><td>combine</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streamdsltotopic-outputpartitionscount-producetype-version-compressiontype-producererrorcallback-outputkafkaconfig-⇒-promiseltbooleangt"></a>streamDSL.to(topic, outputPartitionsCount, produceType, version, compressionType, producerErrorCallback, outputKafkaConfig) ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#streamdsltotopic-outputpartitionscount-producetype-version-compressiontype-producererrorcallback-outputkafkaconfig-⇒-promiseltbooleangt" title="Direct link to heading">#</a></h3><p>define an output topic
when passed to KafkaStreams this will trigger
the stream$ result to be produced to the given topic name
if the instance is a clone, this function call will have to setup a kafka producer
returns a promise</p><p><strong>Kind</strong>: instance method of <a href="#streamdsl"><code>StreamDSL</code></a>  </p><table><thead><tr><th>Param</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>topic</td><td><code>string</code> | <code>Object</code></td><td></td><td>optional (can also be an object, containing the same parameters as fields)</td></tr><tr><td>outputPartitionsCount</td><td><code>number</code></td><td><code>1</code></td><td>optional</td></tr><tr><td>produceType</td><td><code>string</code></td><td><code>&amp;quot;send&amp;quot;</code></td><td>optional</td></tr><tr><td>version</td><td><code>number</code></td><td><code>1</code></td><td>optional</td></tr><tr><td>compressionType</td><td><code>number</code></td><td><code>0</code></td><td>optional</td></tr><tr><td>producerErrorCallback</td><td><code>function</code></td><td></td><td>optional</td></tr><tr><td>outputKafkaConfig</td><td><code>Object</code></td><td></td><td>optional</td></tr></tbody></table></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/nodefluent/kafka-streams/website/docs/classDoc.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/sslSasl"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« SSL, SASL and Kerberos Support</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3klQ"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#summary" class="table-of-contents__link">Summary</a></li><li><a href="#keycount" class="table-of-contents__link">KeyCount</a></li><li><a href="#laststate" class="table-of-contents__link">LastState</a></li><li><a href="#max" class="table-of-contents__link">Max</a></li><li><a href="#min" class="table-of-contents__link">Min</a></li><li><a href="#sum" class="table-of-contents__link">Sum</a></li><li><a href="#window" class="table-of-contents__link">Window</a></li><li><a href="#jskafkaclient" class="table-of-contents__link">JSKafkaClient</a><ul><li><a href="#new-jskafkaclienttopic-config" class="table-of-contents__link">new JSKafkaClient(topic, config)</a></li><li><a href="#jskafkaclientsetproducehandlerhandler" class="table-of-contents__link">jsKafkaClient.setProduceHandler(handler)</a></li><li><a href="#jskafkaclientgetproducehandler-⇒-null--eventemitter" class="table-of-contents__link">jsKafkaClient.getProduceHandler() ⇒ <code>null</code> | <code>EventEmitter</code></a></li><li><a href="#jskafkaclientoverwritetopicstopics" class="table-of-contents__link">jsKafkaClient.overwriteTopics(topics)</a></li><li><a href="#jskafkaclientstartreadycallback-kafkaerrorcallback-withproducer-withbackpressure" class="table-of-contents__link">jsKafkaClient.start(readyCallback, kafkaErrorCallback, withProducer, withBackPressure)</a></li><li><a href="#jskafkaclientsetupproducerproducetopic-partitions-readycallback-kafkaerrorcallback-outputkafkaconfig" class="table-of-contents__link">jsKafkaClient.setupProducer(produceTopic, partitions, readyCallback, kafkaErrorCallback, outputKafkaConfig)</a></li><li><a href="#jskafkaclientsendtopic-message-⇒-" class="table-of-contents__link">jsKafkaClient.send(topic, message) ⇒ <code>*</code></a></li><li><a href="#jskafkaclientbuffertopic-identifier-payload-compressiontype-⇒-" class="table-of-contents__link">jsKafkaClient.buffer(topic, identifier, payload, compressionType) ⇒ <code>*</code></a></li><li><a href="#jskafkaclientbufferformattopic-identifier-payload-version-compressiontype-⇒-" class="table-of-contents__link">jsKafkaClient.bufferFormat(topic, identifier, payload, version, compressionType) ⇒ <code>*</code></a></li></ul></li><li><a href="#nativekafkaclient" class="table-of-contents__link">NativeKafkaClient</a><ul><li><a href="#new-nativekafkaclienttopic-config-batchoptions" class="table-of-contents__link">new NativeKafkaClient(topic, config, batchOptions)</a></li><li><a href="#nativekafkaclientsetproducehandlerhandler" class="table-of-contents__link">nativeKafkaClient.setProduceHandler(handler)</a></li><li><a href="#nativekafkaclientgetproducehandler-⇒-null--eventemitter" class="table-of-contents__link">nativeKafkaClient.getProduceHandler() ⇒ <code>null</code> | <code>EventEmitter</code></a></li><li><a href="#nativekafkaclientoverwritetopicstopics" class="table-of-contents__link">nativeKafkaClient.overwriteTopics(topics)</a></li><li><a href="#nativekafkaclientstartreadycallback-kafkaerrorcallback-withproducer-withbackpressure" class="table-of-contents__link">nativeKafkaClient.start(readyCallback, kafkaErrorCallback, withProducer, withBackPressure)</a></li><li><a href="#nativekafkaclientsetupproducerproducetopic-partitions-readycallback-kafkaerrorcallback-outputkafkaconfig" class="table-of-contents__link">nativeKafkaClient.setupProducer(produceTopic, partitions, readyCallback, kafkaErrorCallback, outputKafkaConfig)</a></li><li><a href="#nativekafkaclientsendtopicname-message-partition-key-partitionkey-opaquekey-⇒-promiseltvoidgt" class="table-of-contents__link">nativeKafkaClient.send(topicName, message, partition, key, partitionKey, opaqueKey) ⇒ <code>Promise.&amp;lt;void&amp;gt;</code></a></li><li><a href="#nativekafkaclientbuffertopic-identifier-payload-_-partition-version-partitionkey-⇒-promiseltvoidgt" class="table-of-contents__link">nativeKafkaClient.buffer(topic, identifier, payload, _, partition, version, partitionKey) ⇒ <code>Promise.&amp;lt;void&amp;gt;</code></a></li><li><a href="#nativekafkaclientbufferformattopic-identifier-payload-version-_-partitionkey-partition-⇒-promiseltvoidgt" class="table-of-contents__link">nativeKafkaClient.bufferFormat(topic, identifier, payload, version, _, partitionKey, partition) ⇒ <code>Promise.&amp;lt;void&amp;gt;</code></a></li></ul></li><li><a href="#kstream" class="table-of-contents__link">KStream</a><ul><li><a href="#new-kstreamtopicname-storage-kafka-isclone" class="table-of-contents__link">new KStream(topicName, storage, kafka, isClone)</a></li><li><a href="#kstreamstartkafkareadycallback-kafkaerrorcallback-withbackpressure-outputkafkaconfig" class="table-of-contents__link">kStream.start(kafkaReadyCallback, kafkaErrorCallback, withBackPressure, outputKafkaConfig)</a></li><li><a href="#kstreaminnerjoinstream-key-windowed-combine-⇒-kstream" class="table-of-contents__link">kStream.innerJoin(stream, key, windowed, combine) ⇒ KStream</a></li><li><a href="#kstreamouterjoinstream" class="table-of-contents__link">kStream.outerJoin(stream)</a></li><li><a href="#kstreamleftjoinstream" class="table-of-contents__link">kStream.leftJoin(stream)</a></li><li><a href="#kstreammergestream-⇒-kstream" class="table-of-contents__link">kStream.merge(stream) ⇒ KStream</a></li><li><a href="#kstreamfrommost-⇒-kstream" class="table-of-contents__link">kStream.fromMost() ⇒ KStream</a></li><li><a href="#kstreamclonecloneevents-clonedeep-⇒-kstream" class="table-of-contents__link">kStream.clone(cloneEvents, cloneDeep) ⇒ KStream</a></li><li><a href="#kstreambranchpreds-⇒-arrayltkstreamgt" class="table-of-contents__link">kStream.branch(preds) ⇒ Array.&lt;KStream&gt;</a></li></ul></li><li><a href="#message--true-" class="table-of-contents__link">(message) =&gt; true ]</a><ul><li><a href="#kstreamwindowfrom-to-etl-encapsulated-collect-⇒-object" class="table-of-contents__link">kStream.window(from, to, etl, encapsulated, collect) ⇒ <code>Object</code></a></li><li><a href="#kstreamclose-⇒-promiseltbooleangt" class="table-of-contents__link">kStream.close() ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code></a></li></ul></li><li><a href="#ktable" class="table-of-contents__link">KTable</a><ul><li><a href="#new-ktabletopicname-keymapetl-storage-kafka-isclone" class="table-of-contents__link">new KTable(topicName, keyMapETL, storage, kafka, isClone)</a></li><li><a href="#ktablestartkafkareadycallback-kafkaerrorcallback-withbackpressure-outputkafkaconfig" class="table-of-contents__link">kTable.start(kafkaReadyCallback, kafkaErrorCallback, withBackPressure, outputKafkaConfig)</a></li><li><a href="#ktableinnerjoinstream-key" class="table-of-contents__link">kTable.innerJoin(stream, key)</a></li><li><a href="#ktableouterjoinstream" class="table-of-contents__link">kTable.outerJoin(stream)</a></li><li><a href="#ktableleftjoinstream" class="table-of-contents__link">kTable.leftJoin(stream)</a></li><li><a href="#ktablewritetotablestreammessage" class="table-of-contents__link">kTable.writeToTableStream(message)</a></li><li><a href="#ktableconsumeuntilmsms-finishedcallback-⇒-ktable" class="table-of-contents__link">kTable.consumeUntilMs(ms, finishedCallback) ⇒ KTable</a></li><li><a href="#ktableconsumeuntilcountcount-finishedcallback-⇒-ktable" class="table-of-contents__link">kTable.consumeUntilCount(count, finishedCallback) ⇒ KTable</a></li><li><a href="#ktableconsumeuntillatestoffsetfinishedcallback" class="table-of-contents__link">kTable.consumeUntilLatestOffset(finishedCallback)</a></li><li><a href="#ktablegettable-⇒-promiseltobjectgt" class="table-of-contents__link">kTable.getTable() ⇒ <code>Promise.&amp;lt;object&amp;gt;</code></a></li><li><a href="#ktablereplay" class="table-of-contents__link">kTable.replay()</a></li><li><a href="#ktablemergestream-⇒-promiseltktablegt" class="table-of-contents__link">kTable.merge(stream) ⇒ Promise.&lt;KTable&gt;</a></li><li><a href="#ktableclone-⇒-promiseltktablegt" class="table-of-contents__link">kTable.clone() ⇒ Promise.&lt;KTable&gt;</a></li><li><a href="#ktableclose-⇒-promiseltbooleangt" class="table-of-contents__link">kTable.close() ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code></a></li></ul></li><li><a href="#streamdsl" class="table-of-contents__link">StreamDSL</a><ul><li><a href="#new-streamdsltopicname-storage-kafka-isclone" class="table-of-contents__link">new StreamDSL(topicName, storage, kafka, isClone)</a></li><li><a href="#streamdslstart" class="table-of-contents__link">streamDSL.start()</a></li><li><a href="#streamdslgetstats-⇒-object" class="table-of-contents__link">streamDSL.getStats() ⇒ <code>object</code></a></li><li><a href="#streamdslgetstorage-⇒-kstorage" class="table-of-contents__link">streamDSL.getStorage() ⇒ <code>KStorage</code></a></li><li><a href="#streamdslwritetostreammessage" class="table-of-contents__link">streamDSL.writeToStream(message)</a></li><li><a href="#streamdslgetmost-⇒-object" class="table-of-contents__link">streamDSL.getMost() ⇒ <code>Object</code></a></li><li><a href="#streamdslgetnewmostfromarray-⇒-streamltanygt" class="table-of-contents__link">streamDSL.getNewMostFrom(array) ⇒ <code>Stream.&amp;lt;any&amp;gt;</code></a></li><li><a href="#streamdslreplaceinternalobservablenewstream" class="table-of-contents__link">streamDSL.replaceInternalObservable(newStream$)</a></li><li><a href="#streamdslsetproducehandlerhandler" class="table-of-contents__link">streamDSL.setProduceHandler(handler)</a></li><li><a href="#streamdslcreateandsetproducehandler-⇒-moduleeventsinternal" class="table-of-contents__link">streamDSL.createAndSetProduceHandler() ⇒ <code>module:events.internal</code></a></li><li><a href="#streamdslsetkafkastreamsreferencereference" class="table-of-contents__link">streamDSL.setKafkaStreamsReference(reference)</a></li><li><a href="#streamdslfromtopicname-⇒-streamdsl" class="table-of-contents__link">streamDSL.from(topicName) ⇒ StreamDSL</a></li><li><a href="#streamdslawaitpromisesetl-⇒-streamdsl" class="table-of-contents__link">streamDSL.awaitPromises(etl) ⇒ StreamDSL</a></li><li><a href="#streamdslmapetl-⇒-streamdsl" class="table-of-contents__link">streamDSL.map(etl) ⇒ StreamDSL</a></li><li><a href="#streamdslasyncmapetl-⇒-streamdsl" class="table-of-contents__link">streamDSL.asyncMap(etl) ⇒ StreamDSL</a></li><li><a href="#streamdslconcatmapetl-⇒-streamdsl" class="table-of-contents__link">streamDSL.concatMap(etl) ⇒ StreamDSL</a></li><li><a href="#streamdslforeacheff-⇒-" class="table-of-contents__link">streamDSL.forEach(eff) ⇒ <code>*</code></a></li><li><a href="#streamdslchainforeacheff-callback-⇒-streamdsl" class="table-of-contents__link">streamDSL.chainForEach(eff, callback) ⇒ StreamDSL</a></li><li><a href="#streamdsltapeff" class="table-of-contents__link">streamDSL.tap(eff)</a></li><li><a href="#streamdslfilterpred-⇒-streamdsl" class="table-of-contents__link">streamDSL.filter(pred) ⇒ StreamDSL</a></li><li><a href="#streamdslskiprepeats-⇒-streamdsl" class="table-of-contents__link">streamDSL.skipRepeats() ⇒ StreamDSL</a></li><li><a href="#streamdslskiprepeatswithequals-⇒-streamdsl" class="table-of-contents__link">streamDSL.skipRepeatsWith(equals) ⇒ StreamDSL</a></li><li><a href="#streamdslskipcount-⇒-streamdsl" class="table-of-contents__link">streamDSL.skip(count) ⇒ StreamDSL</a></li><li><a href="#streamdsltakecount-⇒-streamdsl" class="table-of-contents__link">streamDSL.take(count) ⇒ StreamDSL</a></li><li><a href="#streamdslmapstringtoarraydelimiter-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapStringToArray(delimiter) ⇒ StreamDSL</a></li><li><a href="#streamdslmaparraytokvkeyindex-valueindex-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapArrayToKV(keyIndex, valueIndex) ⇒ StreamDSL</a></li><li><a href="#streamdslmapstringtokvdelimiter-keyindex-valueindex-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapStringToKV(delimiter, keyIndex, valueIndex) ⇒ StreamDSL</a></li><li><a href="#streamdslmapjsonparse-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapJSONParse() ⇒ StreamDSL</a></li><li><a href="#streamdslmapstringify-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapStringify() ⇒ StreamDSL</a></li><li><a href="#streamdslmapbufferkeytostring-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapBufferKeyToString() ⇒ StreamDSL</a></li><li><a href="#streamdslmapbuffervaluetostring-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapBufferValueToString() ⇒ StreamDSL</a></li><li><a href="#streamdslmapstringvaluetojsonobject-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapStringValueToJSONObject() ⇒ StreamDSL</a></li><li><a href="#streamdslmapjsonconvenience-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapJSONConvenience() ⇒ StreamDSL</a></li><li><a href="#streamdslwrapaskafkavaluetopic-⇒-streamdsl" class="table-of-contents__link">streamDSL.wrapAsKafkaValue(topic) ⇒ StreamDSL</a></li><li><a href="#streamdslmapwrapkafkavalue-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapWrapKafkaValue() ⇒ StreamDSL</a></li><li><a href="#streamdslatthroughputcount-callback-⇒-streamdsl" class="table-of-contents__link">streamDSL.atThroughput(count, callback) ⇒ StreamDSL</a></li><li><a href="#streamdslmaptoformattype-getid-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapToFormat(type, getId) ⇒ StreamDSL</a></li><li><a href="#streamdslmapfromformat-⇒-streamdsl" class="table-of-contents__link">streamDSL.mapFromFormat() ⇒ StreamDSL</a></li><li><a href="#streamdsltimestampetl-⇒-streamdsl" class="table-of-contents__link">streamDSL.timestamp(etl) ⇒ StreamDSL</a></li><li><a href="#streamdslconstantsubstitute-⇒-streamdsl" class="table-of-contents__link">streamDSL.constant(substitute) ⇒ StreamDSL</a></li><li><a href="#streamdslscaneff-initial-⇒-streamdsl" class="table-of-contents__link">streamDSL.scan(eff, initial) ⇒ StreamDSL</a></li><li><a href="#streamdslslicestart-end-⇒-streamdsl" class="table-of-contents__link">streamDSL.slice(start, end) ⇒ StreamDSL</a></li><li><a href="#streamdsltakewhilepred-⇒-streamdsl" class="table-of-contents__link">streamDSL.takeWhile(pred) ⇒ StreamDSL</a></li><li><a href="#streamdslskipwhilepred-⇒-streamdsl" class="table-of-contents__link">streamDSL.skipWhile(pred) ⇒ StreamDSL</a></li><li><a href="#streamdsluntilsignal-⇒-streamdsl" class="table-of-contents__link">streamDSL.until(signal$) ⇒ StreamDSL</a></li><li><a href="#streamdslsincesignal-⇒-streamdsl" class="table-of-contents__link">streamDSL.since(signal$) ⇒ StreamDSL</a></li><li><a href="#streamdslcontinuewithf" class="table-of-contents__link">streamDSL.continueWith(f)</a></li><li><a href="#streamdslreduceeff-initial-⇒-" class="table-of-contents__link">streamDSL.reduce(eff, initial) ⇒ <code>*</code></a></li><li><a href="#streamdslchainreduceeff-initial-callback-⇒-streamdsl" class="table-of-contents__link">streamDSL.chainReduce(eff, initial, callback) ⇒ StreamDSL</a></li><li><a href="#streamdsldrain-⇒-" class="table-of-contents__link">streamDSL.drain() ⇒ <code>*</code></a></li><li><a href="#streamdslthrottlethrottleperiod-⇒-streamdsl" class="table-of-contents__link">streamDSL.throttle(throttlePeriod) ⇒ StreamDSL</a></li><li><a href="#streamdsldelaydelaytime-⇒-streamdsl" class="table-of-contents__link">streamDSL.delay(delayTime) ⇒ StreamDSL</a></li><li><a href="#streamdsldebouncedebouncetime-⇒-streamdsl" class="table-of-contents__link">streamDSL.debounce(debounceTime) ⇒ StreamDSL</a></li><li><a href="#streamdslcountbykeykey-countfieldname-⇒-streamdsl" class="table-of-contents__link">streamDSL.countByKey(key, countFieldName) ⇒ StreamDSL</a></li><li><a href="#streamdslsumbykeykey-fieldname-sumfield-⇒-streamdsl" class="table-of-contents__link">streamDSL.sumByKey(key, fieldName, sumField) ⇒ StreamDSL</a></li><li><a href="#streamdslminfieldname-minfield-⇒-streamdsl" class="table-of-contents__link">streamDSL.min(fieldName, minField) ⇒ StreamDSL</a></li><li><a href="#streamdslmaxfieldname-maxfield-⇒-streamdsl" class="table-of-contents__link">streamDSL.max(fieldName, maxField) ⇒ StreamDSL</a></li><li><a href="#streamdsl_mergeotherstream" class="table-of-contents__link">streamDSL._merge(otherStream$)</a></li><li><a href="#streamdsl_zipotherstream-combine" class="table-of-contents__link">streamDSL._zip(otherStream$, combine)</a></li><li><a href="#streamdsltotopic-outputpartitionscount-producetype-version-compressiontype-producererrorcallback-outputkafkaconfig-⇒-promiseltbooleangt" class="table-of-contents__link">streamDSL.to(topic, outputPartitionsCount, produceType, version, compressionType, producerErrorCallback, outputKafkaConfig) ⇒ <code>Promise.&amp;lt;boolean&amp;gt;</code></a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Get Started</a></li></ul></div></div><div class="text--center"><div>Copyright © 2020. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.1a871891.js"></script>
<script src="/runtime~main.e81608d8.js"></script>
<script src="/main.5ae6171e.js"></script>
<script src="/1.c9d93e90.js"></script>
<script src="/2.2ed3b975.js"></script>
<script src="/16.82e5cb28.js"></script>
<script src="/17.6c960b8e.js"></script>
<script src="/20ac7829.45d0d2b4.js"></script>
<script src="/17896441.92507d38.js"></script>
<script src="/9f1a437a.f26d39ae.js"></script>
</body>
</html>