<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus v2.0.0-alpha.61">
<title data-react-helmet="true">Quick Start Tutorial | Kafka streams</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Quick Start Tutorial | Kafka streams"><meta data-react-helmet="true" name="description" content="Requirements"><meta data-react-helmet="true" property="og:description" content="Requirements"><meta data-react-helmet="true" property="og:url" content="https://nodefluent.github.io/kafka-streams/docs/"><link data-react-helmet="true" rel="shortcut icon" href="/kafka-streams/üêô"><link data-react-helmet="true" rel="canonical" href="https://nodefluent.github.io/kafka-streams/docs/"><link rel="stylesheet" href="/kafka-streams/styles.ad8305e2.css">
<link rel="preload" href="/kafka-streams/styles.1a871891.js" as="script">
<link rel="preload" href="/kafka-streams/runtime~main.7b8057bb.js" as="script">
<link rel="preload" href="/kafka-streams/main.796efdb0.js" as="script">
<link rel="preload" href="/kafka-streams/1.c9d93e90.js" as="script">
<link rel="preload" href="/kafka-streams/2.2ed3b975.js" as="script">
<link rel="preload" href="/kafka-streams/16.82e5cb28.js" as="script">
<link rel="preload" href="/kafka-streams/17.6c960b8e.js" as="script">
<link rel="preload" href="/kafka-streams/6c605efb.8fd640ff.js" as="script">
<link rel="preload" href="/kafka-streams/17896441.92507d38.js" as="script">
<link rel="preload" href="/kafka-streams/72e14192.958e40ec.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/kafka-streams/"><strong class="navbar__title">Kafka Streams üêô</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/kafka-streams/docs/">Docs</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/nodefluent/kafka-streams" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">üåú</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">üåû</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/kafka-streams/"><strong class="navbar__title">Kafka Streams üêô</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/kafka-streams/docs/">Docs</a></li><li class="menu__list-item"><a href="https://github.com/nodefluent/kafka-streams" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Usage</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/kafka-streams/docs/">Quick Start Tutorial</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/kafka-streams/docs/handlingMessageSchemas">Message &#x27;to&#x27; and &#x27;from&#x27; Apache Kafka</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/kafka-streams/docs/ksAPI">API info</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/kafka-streams/docs/mostAPI">Operator descriptions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/kafka-streams/docs/native">Native Consumer/Producer Explanation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/kafka-streams/docs/sslSasl">SSL, SASL and Kerberos Support</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/kafka-streams/docs/classDoc">Class Documentation</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Quick Start Tutorial</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="requirements"></a>Requirements<a aria-hidden="true" tabindex="-1" class="hash-link" href="#requirements" title="Direct link to heading">#</a></h2><ul><li>Before you get started, make sure you have installed NodeJS (at least version 6.10, better latest)
running on your system and a local Zookeeper (:2181) and Kafka Broker (:9092) (if you are running
these services elsewhere, make sure to adapt the config settings)</li><li>You can find the latest NodeJS version <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener noreferrer">here</a> (if you did not know already)</li><li>When you are in need of a <code>local</code> kafka setup, just take a look at <code>/kafka-setup/start.sh</code> (you will need docker and docker-compose for this to work)</li><li>Installing kafka-streams in an existing project (directory with package.json) is quite easy: <code>npm install --save kafka-streams</code></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="configuration"></a>Configuration<a aria-hidden="true" tabindex="-1" class="hash-link" href="#configuration" title="Direct link to heading">#</a></h2><ul><li>NOTE: as of version 3.0.0 node-kafka-streams supports an additional <code>librdkafka</code> client,
that offers better performance, configuration tweaking and especially features like
SASL and Kerberos <a href="/kafka-streams/docs/native">checkout the native docs</a> for more details.
<strong>We really want to encourage you to always use the native clients if possible.</strong></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-es6 codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;noptions&quot;: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;metadata.broker.list&quot;: &quot;localhost:9092&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;group.id&quot;: &quot;kafka-streams-test-native&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;client.id&quot;: &quot;kafka-streams-test-name-native&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;event_cb&quot;: true,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;compression.codec&quot;: &quot;snappy&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;api.version.request&quot;: true,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;socket.keepalive.enable&quot;: true,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;socket.blocking.max.ms&quot;: 100,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;enable.auto.commit&quot;: false,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;auto.commit.interval.ms&quot;: 100,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;heartbeat.interval.ms&quot;: 250,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;retry.backoff.ms&quot;: 250,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;fetch.min.bytes&quot;: 100,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;fetch.message.max.bytes&quot;: 2 * 1024 * 1024,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;queued.min.messages&quot;: 100,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;fetch.error.backoff.ms&quot;: 100,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;queued.max.messages.kbytes&quot;: 50,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;fetch.wait.max.ms&quot;: 1000,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;queue.buffering.max.ms&quot;: 1000,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;batch.num.messages&quot;: 10000</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;tconf&quot;: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;auto.offset.reset&quot;: &quot;earliest&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;request.required.acks&quot;: 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;batchOptions&quot;: {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;batchSize&quot;: 5,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;commitEveryNBatch&quot;: 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;concurrency&quot;: 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;commitSync&quot;: false,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;noBatchCommits&quot;: false</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><p>Config is a simple object that is being passed to the constructor of
KafkaStreams, which will result an a new Factory for KStreams and KTables on the
outside and KafkaClients and KStorages on the inside.</p></li><li><p>The sub-object options supports all settings provided by the <code>kafka-node</code>
module.</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-api"></a>The API<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-api" title="Direct link to heading">#</a></h2><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-es6 codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">const {KafkaStreams} = require(&quot;kafka-streams&quot;);</span></div></div></div></div></div><ul><li>Understanding the KafkaStreams object.
A KafkaStreams instance is the representation of a classical &quot;factory&quot;, which will enable you to create
multiple instances of KStreams and KTables using the same configuration for KStorages and KafkaClients easily.
That is why you have to pass a config object to the constructor of KafkaStreams.</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-es6 codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">const kafkaStreams = new KafkaStreams(config);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">kafkaStreams.on(&quot;error&quot;, (error) =&gt; console.error(error));</span></div></div></div></div></div><ul><li>Creating a new KStream (change-log stream representation) via:</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-es6 codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">const kafkaTopicName = &quot;my-topic&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const stream = kafkaStreams.getKStream(kafkaTopicName);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stream.forEach(message =&gt; console.log(message));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stream.start().then(() =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(&quot;stream started, as kafka consumer is ready.&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}, error =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(&quot;streamed failed to start: &quot; + error);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div></div></div></div></div><ul><li><p>Using the factory as base, its simple to create new streams, you can pass a
topic name as string to <code>getKStream()</code> and calling <code>.start()</code> (which returns a Promise,
that will resolve when the Kafka Client is connected &amp; ready to consume messages).</p></li><li><p>Please Note: that you do not have to pass a topic to <code>getKStream()</code> anymore,
you can also simply call <code>stream.from(&quot;topicName&quot;)</code> later. (Also multiple times
to stream from multiple Kafka topics).</p></li><li><p>We highly suggest to read the <a href="/kafka-streams/docs/handlingMessageSchemas">Message Schemas to and from Kafka guide</a></p></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-es6 codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">//format of an incoming kafka message (equals to kafka-node&#x27;s format)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    topic: &quot;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    value: &quot;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    offset: 0,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    partition: 0,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    highWaterOffset: 6,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    key: -1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div></div></div><ul><li><p>When using <code>stream$.to(&quot;topic-name&quot;)</code> to stream the final events of your stream back to another
Kafka Topic, the use of <code>.start()</code> will also cause another Kafka Client to be created and connected
as producer, the promise will then resolve after both, the consumer and the producer have been connected
to the broker successfully.</p></li><li><p>Keep in mind that messages which will be produced to Kafka via <code>.to()</code> will have to be in a string or
object format depending on the type: &quot;send&quot;, &quot;buffer&quot;, &quot;bufferFormat&quot; you pass. Per default the type will be
&quot;send&quot; which requires your events to be a string when reaching the end, using &quot;buffer&quot; or &quot;bufferFormat&quot; will require
your events to be objects when reaching the end of the stream.</p></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-es6 codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">const PRODUCE_TYPES = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SEND: &quot;send&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    BUFFER: &quot;buffer&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    BUFFER_FORMAT: &quot;buffer_format&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">.to(topic, outputPartitionsCount = 1, produceType = &quot;send&quot;, version = 1, compressionType = 0, producerErrorCallback = null)</span></div></div></div></div></div><ul><li><p>You can always call <code>.getKStream()</code> without a topic parameter and there is no requirement to call
<code>.to(..)</code> on a stream - leaving you with an empty stream neither connected as consumer nor producer.</p></li><li><p>Calling <code>.writeToStream(message)</code> will always enable to to add messages/events to a stream manually.</p></li><li><p>By default your node app will keep running, as long as the Kafka Clients in your streams are still connected.
If you want to close a single stream and its clients, simply call <code>stream$.close()</code> if you want to close any Kafka Clients
related to streams created with a KafkaStreams instance, simply call <code>kafkaStreams.closeAll()</code>.</p></li><li><p>You can apply any kind of stream operations to a KStream or KTable instance to get a better feeling of how they
can be combined you should take a look at the <code>/examples</code> folder.</p></li><li><p>By default a KStream instance will always stay open, until you call a completing operation such as <code>.take()</code> or <code>.until()</code>. This is through the nature of most.js streams; which builds the base for any streaming operations, therefore the APIs are very similiar besides the fact that KSteams and KTables <code>DO NOT</code> return a new instance on every operation e.g. <code>stream$.filter(() =&gt; {})</code> (the internal most.js stream is indeed a new one, but the KStream or KTable instance stays the same) But for window and merge|join|combine operations, KStreams and KTables have to return a <code>NEW</code> instance.</p></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-es6 codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">const firstStream = kafkaStreams.getKStream(&quot;first-topic&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const secondStream = kafkaStreams.getKStream(&quot;second-topic&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const mergedStream = firstStream.merge(secondStream); //new KStream instance</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Promise.all([</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    firstStream.start(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    secondStream.start(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    mergedStream.to(&quot;merged-topic&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">.then(() =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(&quot;both consumers and the producer have connected.&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div></div></div></div></div><ul><li><p>Combining streams is simple, keep in mind that <code>.to()</code>, just like <code>.start()</code>, returns a Promise, when
using &quot;to&quot; on a merged stream it will indeed take a little longer as, when it is being used with &quot;start&quot;
as it has to create a new Kafka Client and Producer Connection for the merged stream. However you must not
use <code>.start()</code> on a merged stream.</p></li><li><p>It is also important to understand the concept of observers, when using streams. E.g.:</p></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-es6 codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">const stream = kafkaStreams.getKStream(&quot;my-topic&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stream.map(..).filter(..).tap(message =&gt; console.log(message));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">stream.start();</span></div></div></div></div></div><ul><li><p>You will never see a log in the console using the code above, even though the kafka topic has messages on it, your filter still leaves messages in the stream and you called &quot;start&quot;. And the reason for that is, because the stream is missing an observer. You could either add <code>.drain()</code> or <code>.forEach(m =&gt; {})</code> to the end of the stream to attach an observer.
Keep in mind, that <code>.to()</code> always attaches an observer as well.</p></li><li><p>When using <code>.reduce()</code>, <code>.forEach()</code> or <code>.drain()</code> they return a Promise that will resolve when the stream completes, running this on stream will require 2 things: 1. you should probably only call them on the end (as multiple observers might cause the messages to be emitted multiple times) of a stream. 2. if you are awaiting the resolution of the promise you will have to cause the stream to complete first e.g. by calling <code>.take()</code> before. This behaviour is fundamental to observables.</p></li><li><p>Creating a new KTable (table (last state) representation) via:</p></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-es6 codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">const kafkaTopicName = &quot;my-topic&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const toKv = message =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    const msg = message.split(&quot;,&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        key: msg[0],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        value: msg[1]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const table = kafkaStreams.getKTable(kafkaTopicName, toKv);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">table.consumeUntilCount(100, () =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(&quot;topic has been consumed until count of 100 messages.&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">table.start().then(() =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(&quot;table stream started, as kafka consumer is ready.&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}, error =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(&quot;table streamed failed to start: &quot; + error);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div></div></div></div></div><ul><li><p>The main difference between a KStream and KTable is that the table can only represent a certain moment or state of the total events on a stream (messages on a Kafka Topic) as it has to complete before the table can be build and used. You can either do that by awaiting time <code>.consumeUntilMs(milliseconds)</code> or counting messages <code>.consumeUntilCount(messageCount)</code> or alternatively run until a certain offset is reached with <code>.consumeUntilLatestOffset()</code>.</p></li><li><p>Additionally a KTable needs a second parameter during creation (compared to a KStream) it needs a function that turns any message it might consume from the topic into a {key, value} pair, as a table can only be build on KV pairs.</p></li><li><p>When a table has been built you can access the internal KStorage map, which holds the state of the latest key values.
Via <code>.getTable().then(table =&gt; {})</code> you can also trigger a replay of all KV pairs in the table at any time after completion by calling <code>.replay()</code>.</p></li><li><p>A table can be merged with a KStream or another KTable, keep in mind that when merging 2 KTables their storages will be merged, resulting a combination of both internal KStorage maps. Where the left hand table&#x27;s values might be overwritten by the right hand side, if both contain the equal keys.</p></li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/nodefluent/kafka-streams/website/docs/quick-start.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/kafka-streams/docs/handlingMessageSchemas"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Message &#x27;to&#x27; and &#x27;from&#x27; Apache Kafka ¬ª</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3klQ"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#requirements" class="table-of-contents__link">Requirements</a></li><li><a href="#configuration" class="table-of-contents__link">Configuration</a></li><li><a href="#the-api" class="table-of-contents__link">The API</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/kafka-streams/docs/">Get Started</a></li></ul></div></div><div class="text--center"><div>Copyright ¬© 2020. Built with Docusaurus.</div></div></div></footer></div>
<script src="/kafka-streams/styles.1a871891.js"></script>
<script src="/kafka-streams/runtime~main.7b8057bb.js"></script>
<script src="/kafka-streams/main.796efdb0.js"></script>
<script src="/kafka-streams/1.c9d93e90.js"></script>
<script src="/kafka-streams/2.2ed3b975.js"></script>
<script src="/kafka-streams/16.82e5cb28.js"></script>
<script src="/kafka-streams/17.6c960b8e.js"></script>
<script src="/kafka-streams/6c605efb.8fd640ff.js"></script>
<script src="/kafka-streams/17896441.92507d38.js"></script>
<script src="/kafka-streams/72e14192.958e40ec.js"></script>
</body>
</html>